import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import type { ChangeEvent } from 'react';
import {
  exportSession,
  loadSessionState,
  saveSessionState,
  openAudioFile,
  openVideoFiles,
  readFileBuffer,
  chooseProjectSavePath,
  startRender,
  cancelRender,
  onRenderLog,
  onRenderProgress,
  onRenderDone,
  onRenderError,
  onRenderCancelled,
  openProject,
  updateProjectDirty,
  onProjectRequestSave,
  notifyProjectSaved,
  chooseRenderOutput,
  prepareRenderProject,
  getDefaultProjectPath,
  saveProject,
  loadMediaLibrary,
  saveMediaLibrary as persistMediaLibrary,
  probeMediaFile,
  fileExists,
} from './state/storage';
import type { SessionState } from './types/session';
// ProjectSchema usage comes via storage types; no direct import needed here.
import Waveform from './components/Waveform';
import type { WaveformHandle } from './components/Waveform';
import OverviewWaveform from './components/OverviewWaveform';
import Storyboard from './components/Storyboard';
import VolumeSlider from './components/VolumeSlider';
import type { ProjectSchema, LayerConfig, LayerType } from 'common/project';
import type { MediaLibraryItem } from 'common/project';

type Theme = 'dark' | 'light';
type WebAudioWindow = Window & { webkitAudioContext?: typeof AudioContext };

type LocalSession = SessionState & {
  audioPath?: string;
  videoPaths?: string[];
  projectSavePath?: string;
  playhead?: number;
  layers?: LayerConfig[];
  theme?: Theme;
  canvasPreset?: 'landscape' | 'portrait';
  videoNames?: Record<string, string>;
};

const defaultState: LocalSession = { notes: '', playhead: 0, theme: 'dark', canvasPreset: 'landscape', videoNames: {} };
type LicensePayload = { name?: string; email?: string; edition?: string; issuedAt?: number; expiresAt?: number };
const FONT_FACE_OPTIONS = [
  'Segoe UI',
  'Laritza',
  'Explosion',
  'Explosion-3D',
  'Explosion-Outlined',
  'Explosion-Outlined-3D',
  'Failed',
  'Failed-3D',
  'Failed-3D-Italic',
  'Failed-Italic',
  'Esprit',
  'Essen',
  'Essen3D',
  'Essen-Bold',
  'Essen-Italic',
  'Essere',
  'Essere-Italic',
];

const LICENSE_PUBLIC_KEY_JWK: JsonWebKey = {
  // TODO: replace with your real public key (P-256 / ECDSA) generated by tools/license/sign-license.js.
  "kty": "EC",
  "x": "2wFqyi88_EgpFcQWEzF9aG2knDq39E0iXDKus4yViB4",
  "y": "w1x271OSPw0N9VAEyq9qScubK-66-_dcw8lvh8FQma8",
  "crv": "P-256"
};

const base64UrlToUint8 = (input: string): Uint8Array => {
  const normalized = input.replace(/-/g, '+').replace(/_/g, '/');
  const pad = normalized.length % 4 === 2 ? '==' : normalized.length % 4 === 3 ? '=' : '';
  const b64 = normalized + pad;
  const globalBuffer = typeof globalThis !== 'undefined' ? (globalThis as any).Buffer : undefined;
  const binary = typeof atob === 'function'
    ? atob(b64)
    : (globalBuffer
      ? globalBuffer.from(b64, 'base64').toString('binary')
      : (() => { throw new Error('No base64 decoder available'); })());
  const out = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) out[i] = binary.charCodeAt(i);
  return out;
};

const readDerLength = (bytes: Uint8Array, start: number) => {
  if (start >= bytes.length) return null;
  let len = bytes[start];
  let offset = start + 1;
  if (len & 0x80) {
    const count = len & 0x7f;
    if (count === 0 || count > 2 || offset + count > bytes.length) return null;
    len = 0;
    for (let i = 0; i < count; i++) {
      len = (len << 8) | bytes[offset++];
    }
  }
  return { len, offset };
};

const derToRawEcdsa = (derSig: Uint8Array, size: number): Uint8Array | null => {
  if (derSig.length < 8 || derSig[0] !== 0x30) return null;
  const seq = readDerLength(derSig, 1);
  if (!seq) return null;
  let idx = seq.offset;
  if (idx + seq.len !== derSig.length) return null;
  if (derSig[idx++] !== 0x02) return null;
  const rLenInfo = readDerLength(derSig, idx);
  if (!rLenInfo) return null;
  idx = rLenInfo.offset;
  const rStart = idx;
  const rEnd = rStart + rLenInfo.len;
  if (rEnd > derSig.length) return null;
  let r = derSig.slice(rStart, rEnd);
  idx = rEnd;
  if (derSig[idx++] !== 0x02) return null;
  const sLenInfo = readDerLength(derSig, idx);
  if (!sLenInfo) return null;
  idx = sLenInfo.offset;
  const sStart = idx;
  const sEnd = sStart + sLenInfo.len;
  if (sEnd > derSig.length) return null;
  let s = derSig.slice(sStart, sEnd);
  if (idx + sLenInfo.len !== derSig.length) return null;
  while (r.length > size && r[0] === 0x00) r = r.slice(1);
  while (s.length > size && s[0] === 0x00) s = s.slice(1);
  if (r.length > size || s.length > size) return null;
  const out = new Uint8Array(size * 2);
  out.set(r, size - r.length);
  out.set(s, size + (size - s.length));
  return out;
};

const getSubtle = () => {
  const c = typeof crypto !== 'undefined' ? crypto : (typeof window !== 'undefined' ? (window as any).crypto : undefined);
  if (!c) return null;
  if ((c as any).subtle) return (c as any).subtle;
  if ((c as any).webkitSubtle) return (c as any).webkitSubtle;
  return null;
};

let cachedLicenseKey: CryptoKey | null = null;
const importLicensePublicKey = async () => {
  try {
    if (cachedLicenseKey) return cachedLicenseKey;
    if (!LICENSE_PUBLIC_KEY_JWK.x || !LICENSE_PUBLIC_KEY_JWK.y) return null;
    const subtle = getSubtle();
    if (!subtle) return null;
    cachedLicenseKey = await subtle.importKey(
      'jwk',
      LICENSE_PUBLIC_KEY_JWK,
      { name: 'ECDSA', namedCurve: 'P-256' },
      false,
      ['verify'],
    );
    return cachedLicenseKey;
  } catch (err) {
    console.warn('License public key import failed', err);
    return null;
  }
};

const parseLicensePayload = (bytes: Uint8Array): LicensePayload | null => {
  try {
    const text = new TextDecoder().decode(bytes);
    const json = JSON.parse(text);
    if (json && typeof json === 'object') return json as LicensePayload;
  } catch (err) {
    console.warn('Failed to parse license payload', err);
  }
  return null;
};

const App = () => {
  const [session, setSession] = useState<LocalSession>(defaultState);
  const [status, setStatus] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  const [logs, setLogs] = useState<string[]>([]);
  const [renderElapsedMs, setRenderElapsedMs] = useState<number>(0);
  const [renderTotalMs, setRenderTotalMs] = useState<number>(0);
  const [isRendering, setIsRendering] = useState<boolean>(false);
  const [audioDuration, setAudioDuration] = useState<number>(0);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [showNotes, setShowNotes] = useState<boolean>(false);
  const [videoDurations, setVideoDurations] = useState<Record<string, number>>({});
  const [theme, setThemeChoice] = useState<Theme>('dark');
  const [canvasPreset, setCanvasPreset] = useState<'landscape' | 'portrait'>('landscape');
  const [overviewPeaks, setOverviewPeaks] = useState<number[]>([]);
  const [volume, setVolume] = useState<number>(0.85);
  const waveRef = useRef<WaveformHandle | null>(null);
  const [layerDialogOpen, setLayerDialogOpen] = useState<boolean>(false);
  const [layerDraft, setLayerDraft] = useState<Partial<LayerConfig> & { text?: string; mode?: 'bar' | 'line' | 'solid' | 'dots'; font?: string; fontSize?: number }>({});
  const [timelineZoom, setTimelineZoom] = useState<number>(1);
  const [timelineScroll, setTimelineScroll] = useState<number>(0);
  const layers = useMemo(() => session.layers ?? [], [session.layers]);
  const canvasSize = useMemo(() => (
    canvasPreset === 'portrait'
      ? { width: 1080, height: 1920 }
      : { width: 1920, height: 1080 }
  ), [canvasPreset]);
  const previewCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const videoPoolRef = useRef<Map<string, HTMLVideoElement>>(new Map());
  const [audioEl, setAudioEl] = useState<HTMLAudioElement | null>(null);
  const audioMotionRef = useRef<any>(null);
  const spectroAudioCtxRef = useRef<AudioContext | null>(null);
  const spectroSourceRef = useRef<MediaElementAudioSourceNode | null>(null);
  const spectroAnalyserRef = useRef<AnalyserNode | null>(null);
  const spectroLastDataRef = useRef<Uint8Array | null>(null);
  const previewBusyRef = useRef<boolean>(false);
  const previewQueuedRef = useRef<boolean>(false);
  const spectroCacheRef = useRef<HTMLCanvasElement | null>(null);
  const spectroWorkRef = useRef<HTMLCanvasElement | null>(null);
  const USE_AUDIO_MOTION = false;
  const [library, setLibrary] = useState<MediaLibraryItem[]>([]);
  const [librarySelectedId, setLibrarySelectedId] = useState<string | null>(null);
  const [addVideoModalOpen, setAddVideoModalOpen] = useState<boolean>(false);
  const [missingPaths, setMissingPaths] = useState<Set<string>>(new Set());
  const [contextMenu, setContextMenu] = useState<{ path: string; index: number; x: number; y: number } | null>(null);
  const [renameTarget, setRenameTarget] = useState<{ path: string; index: number; name: string } | null>(null);
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({
    preview: true,
    audio: false,
    videos: false,
    layers: false,
    project: false,
    library: false,
  });
  const [licenseStatus, setLicenseStatus] = useState<{ licensed: boolean; key?: string }>(() => {
    try {
      const raw = localStorage.getItem('muvidgen:license');
      if (raw) {
        const parsed = JSON.parse(raw) as { licensed?: boolean; key?: string };
        return { licensed: !!parsed.licensed, key: parsed.key };
      }
    } catch {}
    return { licensed: false, key: '' };
  });
  const [licenseModalOpen, setLicenseModalOpen] = useState(false);
  const [licenseKeyInput, setLicenseKeyInput] = useState('');
  const [licenseError, setLicenseError] = useState<string | null>(null);
  const [validatingLicense, setValidatingLicense] = useState(false);
  const isLicensed = licenseStatus.licensed;
  const loadLibrary = useCallback(async () => {
    try {
      const items = await loadMediaLibrary();
      setLibrary(items);
    } catch (err) {
      console.warn('Failed to load media library', err);
    }
  }, []);

  const assetHref = (rel: string) => {
    try {
      return new URL(rel, document.baseURI).toString();
    } catch {
      return rel;
    }
  };
  const themedIcon = (rel: string) => {
    if (theme === 'light') {
      const dot = rel.lastIndexOf('.');
      if (dot > 0) {
        const base = rel.slice(0, dot);
        const ext = rel.slice(dot);
        return `${base}-light${ext}`;
      }
    }
    return rel;
  };
  const PillIconButton = ({ icon, label, ...rest }: { icon: string; label: string } & React.ButtonHTMLAttributes<HTMLButtonElement>) => (
    <button className="pill-btn" type="button" {...rest}>
      <img className="pill-btn__img" src={assetHref(icon)} alt="" />
      <span className="pill-btn__label">{label}</span>
    </button>
  );
  const makeId = () => {
    try {
      if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') return crypto.randomUUID();
    } catch {}
    return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  };

  const makePseudoPeaks = useCallback((key: string, buckets = 640) => {
    const peaks: number[] = [];
    let seed = 2166136261;
    for (let i = 0; i < key.length; i++) {
      seed ^= key.charCodeAt(i);
      seed += (seed << 1) + (seed << 4) + (seed << 7) + (seed << 8) + (seed << 24);
    }
    const rand = () => {
      seed ^= seed << 13;
      seed ^= seed >>> 17;
      seed ^= seed << 5;
      return ((seed >>> 0) % 1000) / 1000;
    };
    for (let i = 0; i < buckets; i++) {
      const base = 0.35 + rand() * 0.45;
      // slight smoothing with neighbors
      const prev = i > 0 ? peaks[i - 1] : base;
      peaks.push((base * 0.7) + (prev * 0.3));
    }
    return peaks;
  }, []);
  
  const toFileURL = (absPath: string): string => {
    if (/^file:\/\//i.test(absPath)) return absPath;
    if (/^\\\\/.test(absPath)) {
      const withoutPrefix = absPath.replace(/^\\\\+/, '');
      const normalized = withoutPrefix.replace(/\\/g, '/');
      return 'file://' + encodeURI(normalized);
    }
    const normalized = absPath.replace(/\\/g, '/');
    if (/^[A-Za-z]:\//.test(normalized)) {
      return 'file:///' + encodeURI(normalized);
    }
    if (normalized.startsWith('/')) {
      return 'file:///' + encodeURI(normalized);
    }
    return 'file:///' + encodeURI(normalized.startsWith('/') ? normalized.slice(1) : normalized);
  };
  
  const applyTheme = useCallback((name: Theme) => {
    try {
      localStorage.setItem('muvidgen:theme', name);
    } catch {}
    document.documentElement.setAttribute('data-theme', name);
  }, []);

  useEffect(() => {
    try {
      const saved = localStorage.getItem('muvidgen:theme');
      if (saved === 'light' || saved === 'dark') {
        setThemeChoice(saved);
        return;
      }
    } catch {}
    applyTheme('dark');
  }, [applyTheme]);

  useEffect(() => {
    applyTheme(theme);
  }, [applyTheme, theme]);

  useEffect(() => {
    try {
      localStorage.setItem('muvidgen:license', JSON.stringify(licenseStatus));
    } catch {}
  }, [licenseStatus]);

  useEffect(() => {
    if (licenseModalOpen) {
      setLicenseKeyInput(licenseStatus.key ?? '');
      setLicenseError(null);
    }
  }, [licenseModalOpen, licenseStatus.key]);

  useEffect(() => {
    void loadLibrary();
  }, [loadLibrary]);

  const projectTitle = useMemo(() => {
    const path = session.projectSavePath;
    if (!path) return '';
    const name = path.split(/[\\/]/).pop() || '';
    return name;
  }, [session.projectSavePath]);

  useEffect(() => {
    const base = 'muvid';
    document.title = projectTitle ? `${base} - ${projectTitle}` : base;
  }, [projectTitle]);

  // Check missing media (audio, videos, library) when paths change
  useEffect(() => {
    const checkMissing = async () => {
      const targets = new Set<string>();
      if (session.audioPath) targets.add(session.audioPath);
      (session.videoPaths ?? []).forEach((p) => targets.add(p));
      library.forEach((item) => targets.add(item.path));
      const results = await Promise.all(
        Array.from(targets).map(async (p) => ({ p, ok: await fileExists(p) }))
      );
      const missing = results.filter((r) => !r.ok).map((r) => r.p);
      setMissingPaths(new Set(missing));
    };
    void checkMissing();
  }, [session.audioPath, session.videoPaths, library]);

  // Sync theme from session load
  useEffect(() => {
    if (session.theme === 'light' || session.theme === 'dark') {
      setThemeChoice(session.theme);
    }
  }, [session.theme]);

  // Sync canvas preset from session load
  useEffect(() => {
    if (session.canvasPreset === 'portrait' || session.canvasPreset === 'landscape') {
      setCanvasPreset(session.canvasPreset);
    }
  }, [session.canvasPreset]);

  // Persist theme into session for project-level saves
  useEffect(() => {
    setSession((prev) => (prev.theme === theme ? prev : { ...prev, theme }));
  }, [theme]);

  // Persist canvas preset into session for project-level saves
  useEffect(() => {
    setSession((prev) => (prev.canvasPreset === canvasPreset ? prev : { ...prev, canvasPreset }));
  }, [canvasPreset]);

  // Auto-expand preview when media or layers are present
  useEffect(() => {
    const hasMedia = (session.videoPaths?.length ?? 0) > 0 || (session.layers?.length ?? 0) > 0;
    if (hasMedia) {
      setCollapsed((prev) => (prev.preview ? { ...prev, preview: false } : prev));
    }
  }, [session.videoPaths, session.layers]);

  useEffect(() => {
    // Reset zoom/scroll when audio loads
    if (audioDuration > 0) {
      setTimelineZoom(1);
      setTimelineScroll(0);
    }
  }, [audioDuration]);

  const startNewLayer = (type: LayerType) => {
    const baseWidth = canvasSize.width;
    setLayerDraft({
      id: makeId(),
      type,
      color: '#ffffff',
      x: 0.05,
      y: 0.05,
      rotate: 0,
      opacity: 1,
      reverse: false,
      width: baseWidth,
      height: Math.round(baseWidth * (canvasSize.height / canvasSize.width)),
      lowCutHz: 40,
      highCutHz: 16000,
      mode: type === 'spectrograph' ? 'bar' : undefined,
      invert: type === 'spectrograph' ? false : undefined,
      text: type === 'text' ? 'Text' : undefined,
      font: type === 'text' ? 'Segoe UI' : undefined,
      fontSize: type === 'text' ? 12 : undefined,
    });
    setLayerDialogOpen(true);
  };

  const openEditLayer = (layer: LayerConfig) => {
    setLayerDraft({ ...layer });
    setLayerDialogOpen(true);
  };

  const normalizeLayerDraft = (draft: Partial<LayerConfig>): LayerConfig | null => {
    if (!draft.type || !draft.id) return null;
    const normalized: LayerConfig = { ...(draft as LayerConfig) };
    if (normalized.type === 'spectrograph') {
      normalized.mode = normalized.mode === 'line' || normalized.mode === 'solid' || normalized.mode === 'dots' ? normalized.mode : 'bar';
      if (!normalized.width || !normalized.height) {
        const w = canvasSize.width;
        normalized.width = w;
        normalized.height = Math.round(w * (canvasSize.height / canvasSize.width));
      }
      normalized.opacity = Number.isFinite(normalized.opacity as number) ? normalized.opacity : 1;
      normalized.rotate = Number.isFinite(normalized.rotate as number) ? normalized.rotate : 0;
      normalized.reverse = !!normalized.reverse;
      normalized.invert = !!normalized.invert;
      normalized.lowCutHz = Number.isFinite(normalized.lowCutHz as number) ? normalized.lowCutHz : 40;
      normalized.highCutHz = Number.isFinite(normalized.highCutHz as number) ? normalized.highCutHz : 16000;
    } else if (normalized.type === 'text') {
      normalized.text = normalized.text ?? 'Text';
      normalized.font = normalized.font ?? 'Segoe UI';
      normalized.fontSize = Number(normalized.fontSize ?? 12);
      normalized.opacity = Number.isFinite(normalized.opacity as number) ? normalized.opacity : 1;
      normalized.rotate = Number.isFinite(normalized.rotate as number) ? normalized.rotate : 0;
      normalized.reverse = !!normalized.reverse;
    }
    return normalized;
  };

  const updateLayerDraftField = (partial: Partial<LayerConfig>) => {
    setLayerDraft((prev) => {
      const next = { ...prev, ...partial };
      const normalized = normalizeLayerDraft(next);
      if (normalized) {
        setSession((prevSession) => {
          const existing = prevSession.layers ?? [];
          const idx = existing.findIndex((l) => l.id === normalized.id);
          const newLayers = existing.slice();
          if (idx >= 0) newLayers[idx] = normalized;
          else newLayers.push(normalized);
          return { ...prevSession, layers: newLayers };
        });
        void updateProjectDirty(true);
      }
      return next;
    });
  };

  const saveLayerDraft = () => {
    const normalized = normalizeLayerDraft(layerDraft);
    if (!normalized) return;
    setSession((prev) => {
      const existing = prev.layers ?? [];
      const idx = existing.findIndex((l) => l.id === normalized.id);
      const next = existing.slice();
      if (idx >= 0) next[idx] = normalized;
      else next.push(normalized);
      return { ...prev, layers: next };
    });
    setLayerDialogOpen(false);
    void updateProjectDirty(true);
  };

  const deleteLayer = (id: string) => {
    setSession((prev) => ({ ...prev, layers: (prev.layers ?? []).filter((l) => l.id !== id) }));
    void updateProjectDirty(true);
  };

  const duplicateLayer = (layer: LayerConfig) => {
    const next = { ...layer, id: makeId(), x: Math.min(1, (layer.x ?? 0) + 0.02), y: Math.min(1, (layer.y ?? 0) + 0.02) };
    setSession((prev) => ({ ...prev, layers: [...(prev.layers ?? []), next] }));
    void updateProjectDirty(true);
  };

  const saveLibrary = async (items: MediaLibraryItem[]) => {
    console.info('[library] saveLibrary', { count: items.length });
    setLibrary(items);
    try {
      await persistMediaLibrary(items);
      console.info('[library] persisted to disk');
    } catch (err) {
      console.warn('Failed to save media library', err);
    }
  };

  const updateLibraryName = async (path: string, nextName: string) => {
    const next = library.map((i) => (i.path === path ? { ...i, name: nextName } : i));
    setLibrary(next);
    await saveLibrary(next);
  };

  const addLibraryEntryFromPath = async (filePath: string, name: string) => {
    console.info('[library] addLibraryEntryFromPath', filePath);
    let meta: Partial<MediaLibraryItem> = {};
    try {
      meta = await probeMediaFile(filePath);
    } catch (err) {
      console.warn('Probe failed; adding without metadata', err);
    }
    const item: MediaLibraryItem = {
      id: makeId(),
      name: name.trim(),
      path: filePath,
      description: '',
      duration: meta.duration ? Number(meta.duration) : undefined,
      videoCodec: meta.videoCodec,
      audioCodec: meta.audioCodec,
      audioChannels: meta.audioChannels ? Number(meta.audioChannels) : undefined,
      width: meta.width ? Number(meta.width) : undefined,
      height: meta.height ? Number(meta.height) : undefined,
    };
    await saveLibrary([...library, item]);
    console.info('[library] added item', item);
    return item;
  };

  // Manage hidden video elements for preview
  useEffect(() => {
    const pool = videoPoolRef.current;
    const keep = new Set(session.videoPaths ?? []);
    // remove stale
    for (const key of Array.from(pool.keys())) {
      if (!keep.has(key)) {
        const vid = pool.get(key)!;
        vid.pause();
        pool.delete(key);
      }
    }
    // add new
    for (const p of keep) {
      if (!pool.has(p)) {
        const v = document.createElement('video');
        v.preload = 'metadata';
        v.crossOrigin = 'anonymous';
        v.src = toFileURL(p);
        pool.set(p, v);
      }
    }
  }, [session.videoPaths]);

  const buildProjectFromSession = useCallback((): ProjectSchema => {
    const clips: ProjectSchema['clips'] = (session.videoPaths ?? []).map((p, index) => {
      const clip: ProjectSchema['clips'][number] = { path: p, index, label: (session.videoNames ?? {})[p] };
      const dur = videoDurations[p];
      if (Number.isFinite(dur)) clip.duration = dur;
      return clip;
    });
    const audio = session.audioPath ? { path: session.audioPath } : null;
    const playhead = typeof session.playhead === 'number' && Number.isFinite(session.playhead) ? session.playhead : 0;
    const metadata: Record<string, unknown> = {};
    if (session.theme) metadata.theme = session.theme;
    if (canvasPreset) {
      metadata.canvas = { preset: canvasPreset, width: canvasSize.width, height: canvasSize.height };
    }
    return {
      version: '1.0',
      audio,
      playhead,
      clips,
      layers: session.layers ?? [],
      metadata: Object.keys(metadata).length > 0 ? metadata : undefined,
    };
  }, [canvasPreset, canvasSize.height, canvasSize.width, session.audioPath, session.playhead, session.videoPaths, session.layers, videoDurations]);

  useEffect(() => {
    // Load session
    let cancelled = false;
    loadSessionState()
      .then((state) => {
        if (!cancelled && state) setSession({ ...(state as any), playhead: 0 });
      })
      .catch((err: unknown) => setError(err instanceof Error ? err.message : String(err)));

    // Wire render event listeners
    const offLog = onRenderLog((line) => setLogs((prev) => [...prev, line]));
    const offProgress = onRenderProgress(({ outTimeMs, totalMs }) => {
      if (typeof outTimeMs === 'number') setRenderElapsedMs(outTimeMs);
      if (typeof totalMs === 'number') setRenderTotalMs(totalMs);
    });
    const offDone = onRenderDone(() => {
      setIsRendering(false);
      setStatus('Render completed');
    });
    const offErr = onRenderError((msg) => {
      setIsRendering(false);
      setError(msg);
    });
    const offCancelled = onRenderCancelled(() => {
      setIsRendering(false);
      setStatus('Render cancelled');
    });

    // Handle external save requests (e.g., Ctrl+S from host)
    const offReqSave = onProjectRequestSave(() => {
      void handleSaveProject();
    });

    // Cleanup only (not JSX)
    return () => {
      cancelled = true;
      offLog?.();
      offProgress?.();
      offDone?.();
      offErr?.();
      offCancelled?.();
      offReqSave?.();
    };
  }, []);

  const handleBrowseAudio = async () => {
    try {
      const path = await openAudioFile();
      if (path) {
        setSession((prev) => ({ ...prev, audioPath: path, playhead: 0 }));
        setAudioDuration(0);
        setStatus('Audio selected');
        void updateProjectDirty(true);
      }
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleBrowseVideos = async () => {
    try {
      const paths = await openVideoFiles();
      if (!paths || paths.length === 0) return;
      setSession((prev) => {
        const existing = prev.videoPaths ?? [];
        const nextNames = { ...(prev.videoNames ?? {}) };
        return { ...prev, videoPaths: [...existing, ...paths], videoNames: nextNames };
      });
      setStatus(`${paths.length} video file(s) added`);
      void updateProjectDirty(true);
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const getClipName = (filePath: string) => {
    const suggested = filePath.split(/[\\/]/).pop() || 'Clip';
    if (typeof window !== 'undefined' && typeof window.prompt === 'function') {
      try {
        const res = window.prompt('Enter clip name (required)', suggested);
        const trimmed = (res ?? suggested).trim();
        if (trimmed) return trimmed;
      } catch (err) {
        console.warn('[library] prompt failed, using filename', err);
      }
    }
    return suggested;
  };

  const promptNumeric = (label: string, value: number, min: number | null, max: number | null, onApply: (next: number) => void) => {
    if (typeof window === 'undefined' || typeof window.prompt !== 'function') return;
    const res = window.prompt(`Enter ${label}`, String(value));
    if (res == null) return;
    const parsed = Number(res);
    if (!Number.isFinite(parsed)) return;
    let next = parsed;
    if (min != null) next = Math.max(min, next);
    if (max != null) next = Math.min(max, next);
    onApply(next);
  };

  const handleAddVideoFromLibrary = (item: MediaLibraryItem) => {
    setSession((prev) => {
      const existing = prev.videoPaths ?? [];
      const nextNames = { ...(prev.videoNames ?? {}) };
      nextNames[item.path] = item.name;
      return { ...prev, videoPaths: [...existing, item.path], videoNames: nextNames };
    });
    setStatus(`Added ${item.name} from library`);
    void updateProjectDirty(true);
  };

  const handleBrowseAndAddToLibrary = async () => {
    try {
      const paths = await openVideoFiles();
      console.info('[library] file picker returned', paths);
      if (!paths || paths.length === 0) return;
      let lastId: string | null = null;
      for (const p of paths) {
        const name = getClipName(p);
        const item = await addLibraryEntryFromPath(p, name);
        lastId = item.id;
      }
      if (lastId) {
        setLibrarySelectedId(lastId);
        setCollapsed((prev) => ({ ...prev, library: false }));
        console.info('[library] last added selected', lastId);
      } else {
        console.info('[library] no items added after picker');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
      console.error('[library] add flow failed', err);
    }
  };

  const verifyLicenseKey = useCallback(async (key: string) => {
    const trimmed = key.trim();
    if (!trimmed) return { ok: false, reason: 'Enter a product key.' };
    const subtle = getSubtle();
    if (!subtle) return { ok: false, reason: 'Crypto APIs unavailable in this environment.' };
    const parts = trimmed.split('.');
    if (parts.length !== 2) return { ok: false, reason: 'Invalid format. Expect payload.signature' };
    let payloadBytes: Uint8Array;
    let sigBytes: Uint8Array;
    try {
      payloadBytes = base64UrlToUint8(parts[0]);
      sigBytes = base64UrlToUint8(parts[1]);
    } catch {
      return { ok: false, reason: 'Invalid base64 encoding in key.' };
    }
    const publicKey = await importLicensePublicKey();
    if (!publicKey) return { ok: false, reason: 'Public key not configured; set LICENSE_PUBLIC_KEY_JWK.' };
    let verified = false;
    try {
      verified = await subtle.verify({ name: 'ECDSA', hash: 'SHA-256' }, publicKey, sigBytes, payloadBytes);
      if (!verified && sigBytes[0] === 0x30) {
        const rawSig = derToRawEcdsa(sigBytes, 32);
        if (rawSig) {
          verified = await subtle.verify({ name: 'ECDSA', hash: 'SHA-256' }, publicKey, rawSig, payloadBytes);
        }
      }
    } catch (err) {
      console.warn('License verification error', err);
      return { ok: false, reason: 'Verification failed.' };
    }
    if (!verified) return { ok: false, reason: 'Signature check failed.' };
    const payload = parseLicensePayload(payloadBytes);
    if (!payload) return { ok: false, reason: 'Malformed license payload.' };
    if (payload.expiresAt && Date.now() > payload.expiresAt) return { ok: false, reason: 'License expired.' };
    return { ok: true, payload };
  }, []);

  const ensureLicensed = useCallback(() => {
    if (isLicensed) return true;
    setLicenseModalOpen(true);
    setLicenseError(null);
    setStatus('Trial: upgrade to unlock project actions');
    return false;
  }, [isLicensed]);

  const handleValidateLicense = async () => {
    const trimmed = licenseKeyInput.trim();
    setLicenseError(null);
    setValidatingLicense(true);
    try {
      const result = await verifyLicenseKey(trimmed);
      if (!result.ok) {
        setLicenseError(result.reason ?? 'Invalid product key.');
        return;
      }
      setLicenseStatus({ licensed: true, key: trimmed });
      setLicenseModalOpen(false);
      setStatus('License activated');
    } finally {
      setValidatingLicense(false);
    }
  };

  const handleUnlicense = () => {
    setLicenseStatus({ licensed: false, key: '' });
    setLicenseModalOpen(false);
    setLicenseError(null);
    setStatus('License cleared (testing)');
  };

  const handleNewProject = () => {
    setSession(defaultState);
    setAudioDuration(0);
    setOverviewPeaks([]);
    setTimelineZoom(1);
    setTimelineScroll(0);
    setVideoDurations({});
    setLogs([]);
    setRenderElapsedMs(0);
    setRenderTotalMs(0);
    setIsRendering(false);
    setIsPlaying(false);
    setLayerDraft({});
    setLayerDialogOpen(false);
    setContextMenu(null);
    setRenameTarget(null);
    setMissingPaths(new Set());
    setAddVideoModalOpen(false);
    setLibrarySelectedId(null);
    setStatus('New project');
    setError(null);
    void updateProjectDirty(false);
  };

  const toggleSection = (key: keyof typeof collapsed) => {
    setCollapsed((prev) => ({ ...prev, [key]: !prev[key] }));
  };

  const getClipLabel = useCallback((path: string) => {
    const names = session.videoNames ?? {};
    if (names[path]) return names[path];
    const hit = library.find((i) => i.path === path);
    if (hit?.name) return hit.name;
    return path.split(/[\\/]/).pop() || path;
  }, [library, session.videoNames]);

  const clipNames = useMemo(() => {
    const map: Record<string, string> = {};
    (session.videoPaths ?? []).forEach((p) => { map[p] = getClipLabel(p); });
    return map;
  }, [session.videoPaths, getClipLabel]);
  const projectLocked = !isLicensed;

  const openClipContextMenu = (path: string, index: number, x: number, y: number) => {
    setContextMenu({ path, index, x, y });
  };

  const closeContextMenu = () => setContextMenu(null);


  const removeClipAt = (idx: number) => {
    setSession((prev) => {
      const next = (prev.videoPaths ?? []).slice();
      next.splice(idx, 1);
      return { ...prev, videoPaths: next };
    });
    setContextMenu(null);
    void updateProjectDirty(true);
  };

  const duplicateClipAt = (idx: number) => {
    setSession((prev) => {
      const paths = prev.videoPaths ?? [];
      if (idx < 0 || idx >= paths.length) return prev;
      const dup = paths[idx];
      const next = paths.slice();
      next.splice(idx + 1, 0, dup);
      return { ...prev, videoPaths: next };
    });
    setContextMenu(null);
    void updateProjectDirty(true);
  };

  const startRenameClip = (path: string, index: number) => {
    setRenameTarget({ path, index, name: getClipLabel(path) });
    setContextMenu(null);
  };

  const applyRenameClip = async () => {
    if (!renameTarget) return;
    const { path, name } = renameTarget;
    const trimmed = name.trim();
    const nextName = trimmed || getClipLabel(path);
    const hit = library.find((i) => i.path === path);
    if (hit) {
      await updateLibraryName(path, nextName);
    } else {
      setSession((prev) => ({ ...prev, videoNames: { ...(prev.videoNames ?? {}), [path]: nextName } }));
    }
    setStatus(`Renamed clip to ${nextName}`);
    setRenameTarget(null);
    void updateProjectDirty(true);
  };

  const handleClipInfo = (path: string) => {
    const label = getClipLabel(path);
    const dur = videoDurations[path];
    setStatus(`Clip: ${label} (${dur ? `${dur.toFixed(1)}s` : 'n/a'})`);
    setContextMenu(null);
  };

  const handleClipEdit = (path: string) => {
    const hit = library.find((i) => i.path === path);
    if (hit) {
      setLibrarySelectedId(hit.id);
      setCollapsed((prev) => ({ ...prev, library: false }));
    }
    setContextMenu(null);
  };

  const handleClipAddToLibrary = async (path: string) => {
    const exists = library.some((item) => item.path === path);
    if (exists) {
      setContextMenu(null);
      return;
    }
    const name = getClipLabel(path);
    await addLibraryEntryFromPath(path, name);
    setContextMenu(null);
  };

  const handleLoadProject = async () => {
    if (!ensureLicensed()) return;
    try {
      const opened = await openProject();
      if (opened) {
        const project = opened.project as any;
        const nextVideos = Array.isArray(project?.clips) ? project.clips.map((c: any) => c?.path).filter(Boolean) : [];
        const nextNames: Record<string, string> = {};
        if (Array.isArray(project?.clips)) {
          project.clips.forEach((c: any) => {
            if (c?.path && c.label) nextNames[c.path] = c.label;
          });
        }
        setSession((prev) => ({
          ...prev,
          projectSavePath: opened.path,
          audioPath: project?.audio?.path ?? undefined,
          videoPaths: nextVideos,
          videoNames: nextNames,
          playhead: typeof project?.playhead === 'number' ? project.playhead : 0,
          layers: Array.isArray(project?.layers) ? project.layers : [],
        }));
        setStatus('Project loaded');
        await updateProjectDirty(false);
      }
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleSaveProject = async () => {
    if (!ensureLicensed()) return;
    try {
      const project = buildProjectFromSession();
      let target = session.projectSavePath;
      if (!target) {
        const defaultPath = await getDefaultProjectPath();
        target = await chooseProjectSavePath(defaultPath);
        if (!target) return;
        setSession((prev) => ({ ...prev, projectSavePath: target }));
      }
      await saveProject(target, project);
      await updateProjectDirty(false);
      notifyProjectSaved(true);
      setStatus('Project saved');
    } catch (e: unknown) {
      notifyProjectSaved(false);
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleSaveProjectAs = async () => {
    if (!ensureLicensed()) return;
    try {
      const defaultPath = session.projectSavePath ?? await getDefaultProjectPath();
      const target = await chooseProjectSavePath(defaultPath);
      if (!target) return;
      setSession((prev) => ({ ...prev, projectSavePath: target }));
      const project = buildProjectFromSession();
      await saveProject(target, project);
      await updateProjectDirty(false);
      notifyProjectSaved(true);
      setStatus('Project saved as...');
    } catch (e: unknown) {
      notifyProjectSaved(false);
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleStartRender = async () => {
    if (!ensureLicensed()) return;
    try {
      const project = buildProjectFromSession();
      let target = session.projectSavePath;
      if (!target) {
        const defaultPath = await getDefaultProjectPath();
        target = await chooseProjectSavePath(defaultPath);
        if (!target) {
          setStatus('Render cancelled: no project path selected');
          return;
        }
        setSession((prev) => ({ ...prev, projectSavePath: target }));
      }
      await saveProject(target, project);
      await updateProjectDirty(false);

      const outputPath = await chooseRenderOutput(target);
      if (!outputPath) {
        setStatus('Render cancelled');
        return;
      }
      const preparedPath = await prepareRenderProject(target, outputPath);

      setIsRendering(true);
      setRenderElapsedMs(0);
      setRenderTotalMs(0);
      setLogs([]);
      setStatus('Render started');
      void startRender(preparedPath).catch((err) => {
        setIsRendering(false);
        setError(err instanceof Error ? err.message : String(err));
      });
    } catch (e: unknown) {
      setIsRendering(false);
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleNotesChange = (ev: ChangeEvent<HTMLTextAreaElement>) => {
    const value = ev.target.value;
    setSession((prev) => ({ ...prev, notes: value }));
    void updateProjectDirty(true);
  };

  const handleSave = async () => {
    try {
      const { audioPath, videoPaths, projectSavePath, playhead, ...rest } = session;
      const toSave: SessionState = { ...(rest as SessionState) };
      await saveSessionState(toSave);
      setStatus('Session saved');
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleExport = async () => {
    try {
      const targetPath = session.projectSavePath;
      if (!targetPath) {
        setError('Set a project path before export');
        return;
      }
      await exportSession({ targetPath, state: (session as unknown as SessionState) });
      setStatus('Session exported');
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  // Load video durations to scale storyboard items
  useEffect(() => {
    const paths = session.videoPaths ?? [];
    if (paths.length === 0) { setVideoDurations({}); return; }
    let cancel = false;
    const next: Record<string, number> = {};
    let loaded = 0;
    paths.forEach((p) => {
      const v = document.createElement('video');
      v.preload = 'metadata';
      v.src = toFileURL(p);
      const done = () => {
        loaded += 1;
        if (!cancel) {
          if (Number.isFinite(v.duration)) next[p] = v.duration;
          if (loaded === paths.length) setVideoDurations(next);
        }
        v.src = '';
      };
      v.addEventListener('loadedmetadata', done, { once: true });
      v.addEventListener('error', done, { once: true });
      // In case metadata is cached
      if (Number.isFinite(v.duration) && v.duration > 0) done();
    });
    return () => { cancel = true; };
  }, [session.videoPaths]);

  useEffect(() => {
    const audioPath = session.audioPath;
    if (!audioPath) {
      setOverviewPeaks([]);
      return;
    }
    // Show something immediately while decoding
    setOverviewPeaks(makePseudoPeaks(audioPath));
    let cancelled = false;

    const generatePeaks = async () => {
      try {
        const buf = await readFileBuffer(audioPath);
        const slice = buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength
          ? buf.buffer
          : buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        // Ensure we hand AudioContext a real ArrayBuffer (not SharedArrayBuffer)
        const arrayBuffer = slice instanceof ArrayBuffer
          ? slice
          : (() => {
              const copy = new Uint8Array(slice.byteLength);
              copy.set(new Uint8Array(slice));
              return copy.buffer;
            })();
        const AudioCtor = window.AudioContext || (window as WebAudioWindow).webkitAudioContext;
        if (!AudioCtor) throw new Error('AudioContext unavailable');
        const audioCtx = new AudioCtor();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        if (cancelled) {
          await audioCtx.close();
          return;
        }
        const channelData = decoded.numberOfChannels > 0 ? decoded.getChannelData(0) : undefined;
        if (!channelData) {
          await audioCtx.close();
          throw new Error('No channel data');
        }
        const bucketCount = 640;
        const samplesPerBucket = Math.max(1, Math.floor(channelData.length / bucketCount));
        const peaks: number[] = [];
        for (let bucket = 0; bucket < bucketCount; bucket++) {
          const start = bucket * samplesPerBucket;
          if (start >= channelData.length) break;
          let peak = 0;
          for (let i = 0; i < samplesPerBucket && start + i < channelData.length; i++) {
            const sample = Math.abs(channelData[start + i]);
            if (sample > peak) peak = sample;
          }
          peaks.push(peak);
        }
        await audioCtx.close();
        if (!cancelled) setOverviewPeaks(peaks);
      } catch (err) {
        if (!cancelled) {
          console.warn('Overview waveform generation failed:', err);
          setOverviewPeaks(makePseudoPeaks(audioPath));
        }
      }
    };

    void generatePeaks();
    return () => {
      cancelled = true;
    };
  }, [session.audioPath, makePseudoPeaks]);

  // Wire AudioMotion analyzer when audio element is available (lazy-loaded from CDN)
  useEffect(() => {
    if (!USE_AUDIO_MOTION) return;
    const audio = audioEl;
    if (!audio) return;
    let container: HTMLDivElement | null = null;
    let destroyed = false;
    (async () => {
      try {
        // @ts-ignore external ESM import
        const mod: any = await import(/* @vite-ignore */ 'https://cdn.jsdelivr.net/npm/audiomotion-analyzer@4.0.0/+esm');
        const AudioMotion = mod?.default ?? mod;
        if (!AudioMotion) return;
        if (destroyed) return;
        container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.left = '-9999px';
        container.style.top = '-9999px';
        container.style.width = '400px';
        container.style.height = '200px';
        document.body.appendChild(container);
        const am = new AudioMotion(container, {
          source: audio,
          height: 200,
          width: 400,
          mode: 10,
          ledBars: false,
          ansiBands: false,
          smoothing: 0.7,
          gradient: 'classic',
          showScale: false,
          overlay: true,
          bgAlpha: 0,
          showPeaks: false,
        });
        audioMotionRef.current = am;
      } catch (err) {
        console.warn('AudioMotion init failed', err);
      }
    })();
    return () => {
      destroyed = true;
      if (audioMotionRef.current) {
        try { (audioMotionRef.current as any).destroy?.(); } catch {}
        audioMotionRef.current = null;
      }
      if (container) {
        container.remove();
      }
    };
  }, [USE_AUDIO_MOTION, audioEl, session.audioPath]);

  useEffect(() => {
    const audio = audioEl;
    if (!audio) return undefined;
    let ctx: AudioContext | null = null;
    let source: MediaElementAudioSourceNode | null = null;
    let analyser: AnalyserNode | null = null;
    const cleanup = () => {
      try { source?.disconnect(); } catch {}
      try { analyser?.disconnect(); } catch {}
      if (ctx) {
        try { ctx.close(); } catch {}
      }
      spectroAudioCtxRef.current = null;
      spectroSourceRef.current = null;
      spectroAnalyserRef.current = null;
    };
    try {
      const AudioCtor = window.AudioContext || (window as WebAudioWindow).webkitAudioContext;
      if (!AudioCtor) return cleanup;
      ctx = new AudioCtor();
      source = ctx.createMediaElementSource(audio);
      analyser = ctx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.7;
      source.connect(analyser);
      analyser.connect(ctx.destination);
      spectroAudioCtxRef.current = ctx;
      spectroSourceRef.current = source;
      spectroAnalyserRef.current = analyser;
      const onPlay = () => { void ctx?.resume(); };
      audio.addEventListener('play', onPlay);
      return () => {
        audio.removeEventListener('play', onPlay);
        cleanup();
      };
    } catch {
      cleanup();
      return undefined;
    }
  }, [audioEl]);

  const resolveActiveClip = useCallback((playheadSec: number) => {
    const paths = session.videoPaths ?? [];
    let acc = 0;
    for (const p of paths) {
      const dur = videoDurations[p] ?? 0;
      const next = acc + dur;
      if (playheadSec <= next) {
        return { path: p, local: Math.max(0, playheadSec - acc), duration: dur };
      }
      acc = next;
    }
    return null;
  }, [session.videoPaths, videoDurations]);

  const renderPreviewFrame = useCallback(async () => {
    if (previewBusyRef.current) {
      previewQueuedRef.current = true;
      return;
    }
    const canvas = previewCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    previewBusyRef.current = true;
    const dpr = window.devicePixelRatio || 1;
    const logicalW = canvas.clientWidth || 800;
    const logicalH = canvas.clientHeight || 450;
    const stageAspect = canvasSize.width / canvasSize.height;
    const stageW = (logicalW / logicalH) > stageAspect ? (logicalH * stageAspect) : logicalW;
    const stageH = stageW / stageAspect;
    const stageX = (logicalW - stageW) / 2;
    const stageY = (logicalH - stageH) / 2;
    const stageScale = stageW / canvasSize.width;
    canvas.width = Math.floor(logicalW * dpr);
    canvas.height = Math.floor(logicalH * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, logicalW, logicalH);
    ctx.fillStyle = '#0b0f16';
    ctx.fillRect(0, 0, logicalW, logicalH);

    const active = resolveActiveClip(session.playhead ?? 0);
    if (active) {
      const vid = videoPoolRef.current.get(active.path);
      if (vid) {
        const targetTime = Math.min(Math.max(0, active.local), (vid.duration || active.duration || 0));
        let seekOk = false;
        if (vid.readyState >= 2 && Math.abs((vid.currentTime || 0) - targetTime) < 0.01) {
          seekOk = true;
        } else {
          seekOk = await new Promise<boolean>((resolve) => {
            const handler = () => resolve(true);
            vid.currentTime = targetTime;
            vid.addEventListener('seeked', handler, { once: true });
            setTimeout(() => resolve(false), 500);
          });
        }
        if (seekOk) {
          try {
            const vw = vid.videoWidth || logicalW;
            const vh = vid.videoHeight || logicalH;
            const scale = Math.min(stageW / vw, stageH / vh);
            const dw = vw * scale;
            const dh = vh * scale;
            const dx = stageX + (stageW - dw) / 2;
            const dy = stageY + (stageH - dh) / 2;
            ctx.drawImage(vid, dx, dy, dw, dh);
          } catch {
            // ignore draw errors
          }
        }
      }
    }

    // Draw layers
    for (const layer of layers) {
      const x = stageX + (layer.x ?? 0) * stageW;
      const y = stageY + (layer.y ?? 0) * stageH;
      const baseW = layer.width ?? canvasSize.width;
      const baseH = layer.height ?? Math.round(baseW * (canvasSize.height / canvasSize.width));
      const drawW = Math.max(10, baseW * stageScale);
      const drawH = Math.max(10, baseH * stageScale);
      const opacity = Math.min(1, Math.max(0, layer.opacity ?? 1));
      const rotateDeg = layer.rotate ?? 0;
      const rotateRad = (rotateDeg * Math.PI) / 180;
      const reverse = !!layer.reverse;
      if (layer.type === 'spectrograph') {
        const analyser = spectroAnalyserRef.current;
        if (analyser) {
          const workCanvas = spectroWorkRef.current ?? document.createElement('canvas');
          if (!spectroWorkRef.current) spectroWorkRef.current = workCanvas;
          const barCanvasW = 512;
          const barCanvasH = 200;
          workCanvas.width = barCanvasW;
          workCanvas.height = barCanvasH;
          const workCtx = workCanvas.getContext('2d');
          if (!workCtx) continue;
          workCtx.clearRect(0, 0, barCanvasW, barCanvasH);
          const data = new Uint8Array(analyser.frequencyBinCount);
          const live = !!audioEl && !audioEl.paused;
          if (live) {
            analyser.getByteFrequencyData(data);
            spectroLastDataRef.current = data.slice();
          } else if (spectroLastDataRef.current && spectroLastDataRef.current.length === data.length) {
            data.set(spectroLastDataRef.current);
          } else {
            analyser.getByteFrequencyData(data);
          }
          const barCount = 96;
          const step = Math.max(1, Math.floor(data.length / barCount));
          const barW = barCanvasW / barCount;
          const fill = layer.color ?? '';
          let gradient: CanvasGradient | null = null;
          if (!fill) {
            gradient = workCtx.createLinearGradient(0, 0, 0, barCanvasH);
            gradient.addColorStop(0, '#ff3b3b');
            gradient.addColorStop(0.55, '#ffd400');
            gradient.addColorStop(1, '#00ff7a');
          }
          workCtx.fillStyle = fill || gradient || '#00ff7a';
          for (let i = 0; i < barCount; i++) {
            const v = data[i * step] / 255;
            const h = Math.max(1, Math.floor(v * barCanvasH));
            const xPos = i * barW;
            const yPos = layer.invert ? 0 : (barCanvasH - h);
            workCtx.fillRect(xPos, yPos, Math.max(1, barW * 0.8), h);
          }
          const finalCanvas = workCanvas;
          const glowAmount = layer.glowAmount ?? 0;
          const glowOpacity = layer.glowOpacity ?? 0.4;
          const glowColor = layer.glowColor ?? layer.color ?? '#ffffff';
          const outlineWidth = layer.outlineWidth ?? 0;
          const outlineColor = layer.outlineColor ?? '#000000';
          const shadowDistance = layer.shadowDistance ?? 0;
          const shadowColor = layer.shadowColor ?? '#000000';
          ctx.save();
          ctx.translate(x + drawW / 2, y + drawH / 2);
          ctx.rotate(rotateRad);
          if (reverse) ctx.scale(-1, 1);
          ctx.globalAlpha = opacity;
          if (shadowDistance > 0) {
            ctx.save();
            ctx.shadowOffsetX = shadowDistance;
            ctx.shadowOffsetY = shadowDistance;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 0;
            ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();
          }
          if (outlineWidth > 0) {
            ctx.save();
            ctx.shadowColor = outlineColor;
            ctx.shadowBlur = outlineWidth;
            ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();
          }
          if (glowAmount > 0) {
            ctx.save();
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = glowAmount;
            ctx.globalAlpha = glowOpacity;
            ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();
          }
          ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
          ctx.restore();
        } else {
          const am = audioMotionRef.current;
          if (am?.canvas) {
            try { am.draw?.(); } catch {}
            const srcCanvas = am.canvas as HTMLCanvasElement;
            const sourceW = srcCanvas.width;
            const sourceH = Math.floor(srcCanvas.height * 0.8);
            const cacheCanvas = spectroCacheRef.current ?? document.createElement('canvas');
            if (!spectroCacheRef.current) spectroCacheRef.current = cacheCanvas;
            cacheCanvas.width = sourceW;
            cacheCanvas.height = sourceH;
            const cacheCtx = cacheCanvas.getContext('2d');
            if (cacheCtx) {
              cacheCtx.clearRect(0, 0, sourceW, sourceH);
              cacheCtx.drawImage(srcCanvas, 0, 0, sourceW, sourceH, 0, 0, sourceW, sourceH);
            }
            ctx.save();
            ctx.translate(x + drawW / 2, y + drawH / 2);
            ctx.rotate(rotateRad);
            if (reverse) ctx.scale(-1, 1);
            ctx.globalAlpha = opacity;
            ctx.drawImage(cacheCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();
          } else {
            // Fallback visual if analyser not ready
            ctx.save();
            ctx.fillStyle = layer.color ?? '#7ea5ff';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(x, y, drawW, drawH);
            ctx.restore();
          }
        }
      } else if (layer.type === 'text') {
        ctx.save();
        ctx.translate(x + drawW / 2, y + drawH / 2);
        ctx.rotate(rotateRad);
        if (reverse) ctx.scale(-1, 1);
        ctx.globalAlpha = opacity;
        const fontSize = Math.max(8, layer.fontSize ?? 12);
        ctx.font = `${fontSize}px ${layer.font ?? 'Segoe UI'}, sans-serif`;
        ctx.fillStyle = layer.color ?? '#ffffff';
        const shadowOpacity = layer.glowOpacity ?? 0.4;
        if (layer.glowAmount) {
          ctx.shadowColor = `${layer.glowColor ?? layer.color ?? '#ffffff'}${Math.round(shadowOpacity * 255).toString(16).padStart(2, '0')}`;
          ctx.shadowBlur = layer.glowAmount ?? 0;
        } else {
          ctx.shadowBlur = 0;
        }
        if (layer.shadowDistance) {
          ctx.shadowOffsetX = layer.shadowDistance;
          ctx.shadowOffsetY = layer.shadowDistance;
          ctx.shadowColor = layer.shadowColor ?? '#000000';
        }
        ctx.strokeStyle = layer.outlineColor ?? '#000000';
        ctx.lineWidth = Math.max(0, layer.outlineWidth ?? 0);
        if ((layer.outlineWidth ?? 0) > 0) {
          ctx.strokeText(layer.text ?? 'Text', -drawW / 2, 0);
        }
        ctx.fillText(layer.text ?? 'Text', -drawW / 2, 0);
        ctx.restore();
      }
    }

    previewBusyRef.current = false;
    if (previewQueuedRef.current) {
      previewQueuedRef.current = false;
      requestAnimationFrame(() => { void renderPreviewFrame(); });
    }
  }, [audioEl, canvasSize, layers, resolveActiveClip, session.playhead]);

  useEffect(() => {
    void renderPreviewFrame();
  }, [renderPreviewFrame, session.playhead, layers, videoDurations, session.videoPaths]);

  useEffect(() => {
    const onResize = () => { void renderPreviewFrame(); };
    window.addEventListener('resize', onResize);
    return () => window.removeEventListener('resize', onResize);
  }, [renderPreviewFrame]);

  return (
    <div style={{ padding: 2 }}>
      <div className="grid">

        {/* Preview Row */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: '1px 0px' }}>PREVIEW</h2>
            <div style={{ marginLeft: 'auto' }}>

            
                <label style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', gap: 10, color: 'var(--text)', fontWeight: 600 }}>
                Theme
                <select 
                  value={theme}
                  onChange={(e) => {
                    const next = e.target.value === 'light' ? 'light' : 'dark';
                    setThemeChoice(next);
                  }}
                  style={{ background: 'var(--panel-alt)', color: 'var(--text)', fontSize: 16, fontFamily: "Tahoma", fontWeight: 200, border: '1px solid var(--border)', borderRadius: 8, margin: 'auto', padding: '6px 4px' }}
                >
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                </select>
              
              <button className="collapse-btn" type="button" onClick={() => toggleSection('preview')} aria-label="Toggle preview">
                <img src={assetHref(themedIcon(collapsed.preview ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.preview ? 'Expand' : 'Collapse'} />
              </button>
              </label>
              </div>
          </div>
          {!collapsed.preview && (
            <div className="section-body" style={{ padding: 0 }}>
              <canvas ref={previewCanvasRef} style={{ width: '100%', height: 320, display: 'block', borderRadius: 8, background: '#0b0f16' }} />
            </div>
          )}
        </div>

        {/* Media Row */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>MEDIA</h2>
            <button className="pill-btn" type="button" title="Load Audio" aria-label="Load Audio" onClick={handleBrowseAudio}>
              <img className="pill-btn__img" src={assetHref('ui/icon-audio-load.png')} alt="" />
              <span className="pill-btn__label">Load Audio</span>
            </button>
            <PillIconButton icon="ui/icon-video-add.png" label="Browse" onClick={handleBrowseVideos} />
            <PillIconButton icon="ui/icon-video.png" label="From Library" onClick={() => setAddVideoModalOpen(true)} />

            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 8 }}>
              <VolumeSlider value={volume} onChange={(v) => setVolume(Math.min(1, Math.max(0, v)))} width={180} />
              <div className="pill-btn" role="group" aria-label="Timeline zoom">
                <button className="pill-btn" style={{ border: '0px', padding: '0px' }} type="button" onClick={() => { setTimelineZoom((z) => Math.max(0.25, z / 2)); setTimelineScroll(0); }} aria-label="Zoom out">
                  <img className="pill-btn__img" src={assetHref('ui/icon-zoom-minus.png')} alt="" />
                </button>
                <span className="muted" style={{ minWidth: 60, lineHeight: 0.6, textAlign: 'center' }}>{Math.round(timelineZoom * 100)}%</span>
                <button className="pill-btn" style={{ border: '0px', padding: '0px' }} type="button" onClick={() => { setTimelineZoom((z) => Math.min(8, z * 2)); setTimelineScroll(0); }} aria-label="Zoom in">
                  <img className="pill-btn__img" src={assetHref('ui/icon-zoom-plus.png')} alt="" />
                </button>
              </div>
              <button className="pill-btn" type="button" onClick={() => { setTimelineZoom(1); setTimelineScroll(0); }}>
                <img className="pill-btn__img" src={assetHref('ui/icon-zoom-fit.png')} alt="" />
                <span className="pill-btn__label">Fit</span>
              </button>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('audio')} aria-label="Toggle media">
                <img src={assetHref(themedIcon(collapsed.audio ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.audio ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>
          {!collapsed.audio && (
            <div className="section-body" style={{ padding: 0, position: 'relative', overflow: 'hidden' }}>
              <div style={{ position: 'relative' }}>
                <OverviewWaveform
                  duration={audioDuration}
                  playhead={session.playhead ?? 0}
                  onSeek={(t: number) => setSession((prev) => ({ ...prev, playhead: t }))}
                  peaks={overviewPeaks}
                  hasAudio={!!session.audioPath}
                  zoom={timelineZoom}
                  scroll={timelineScroll}
                  onEmptyClick={handleBrowseAudio}
                />
                <div style={{ position: 'absolute', left: 8, top: 6, flexDirection: 'column' }}>
                  <button className="pill-btn pill-btn--compact" style={{ position: 'relative', top: '25px', width: '60px', height: '60px', borderRadius: '20px' }} type="button" title={isPlaying ? 'Pause' : 'Play'} aria-label={isPlaying ? 'Pause' : 'Play'} onClick={() => waveRef.current?.toggle()} disabled={!session.audioPath}>
                    <img className="pill-btn__img" style={{ position: 'relative', top: '0px', width: '45px', height: '45px' }} src={assetHref(isPlaying ? 'ui/icon-audio-pause.png' : 'ui/icon-audio-play.png')} alt="" />
                  </button>
                </div>

                <div className="time-pill" style={{ position: 'absolute', right: 8, bottom: 6 }}>
                  <span>{Math.floor(session.playhead ?? 0)}s</span>
                  <span>/</span>
                  <span>{Math.floor(audioDuration)}s</span>
                </div>
                <Waveform
                  ref={waveRef as any}
                  srcPath={session.audioPath ?? ''}
                  playhead={session.playhead ?? 0}
                  onPlayheadChange={(t) => setSession((prev) => ({ ...prev, playhead: t }))}
                  onDurationChange={(d) => setAudioDuration(d)}
                  onPlayingChange={(p) => setIsPlaying(p)}
                  volume={volume}
                  hideBuiltInControls
                  hideCanvas
                  onAudioElement={(el) => { setAudioEl(el); }}
                />
              </div>
              <div style={{ marginTop: 4 }}>
                {(session.videoPaths?.length ?? 0) > 0 ? (
                  <Storyboard
                    paths={session.videoPaths ?? []}
                    onChange={(next) => {
                      setSession((prev) => ({ ...prev, videoPaths: next }));
                      void updateProjectDirty(true);
                    }}
                    durations={videoDurations}
                    names={clipNames}
                    missingPaths={missingPaths}
                    totalDuration={audioDuration}
                    zoom={timelineZoom}
                    scroll={timelineScroll}
                    playhead={session.playhead ?? 0}
                    theme={theme}
                    onContextMenu={openClipContextMenu}
                    onDoubleClick={(path) => {
                      const hit = (library.find((i) => i.path === path));
                      if (hit) {
                        setCollapsed((prev) => ({ ...prev, library: false }));
                        setLibrarySelectedId(hit.id);
                      } else {
                        setCollapsed((prev) => ({ ...prev, library: false }));
                      }
                    }}
                  />
                ) : (
                  <div className="muted" style={{ marginTop: 2 }}>No clips. Use Browse or From Library to include files.</div>
                )}
              </div>
              {session.audioPath && (
                <div style={{ marginTop: 4, padding: '2px 8px' }}>
                  <div style={{ height: 12, background: '#1e2432', borderRadius: 6, position: 'relative' }} onClick={(e) => {
                    const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect();
                    const pct = Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
                    setTimelineScroll(pct);
                  }}>
                    <div
                      style={{
                        position: 'absolute',
                        left: `${Math.min(1, Math.max(0, timelineScroll)) * Math.max(0, 1 - 1 / Math.max(1, timelineZoom)) * 100}%`,
                        top: 2,
                        height: 8,
                        width: `${Math.min(100, (1 / Math.max(1, timelineZoom)) * 100)}%`,
                        background: '#3f51b5',
                        borderRadius: 4,
                        cursor: 'pointer',
                      }}
                      onMouseDown={(e) => {
                        e.preventDefault();
                        const onMove = (ev: MouseEvent) => {
                          const rect = (e.currentTarget!.parentElement as HTMLDivElement).getBoundingClientRect();
                          const pct = Math.min(1, Math.max(0, (ev.clientX - rect.left) / rect.width));
                          setTimelineScroll(pct);
                        };
                        const onUp = () => {
                          window.removeEventListener('mousemove', onMove);
                          window.removeEventListener('mouseup', onUp);
                        };
                        window.addEventListener('mousemove', onMove);
                        window.addEventListener('mouseup', onUp);
                      }}
                    />
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Layers Row */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>LAYERS</h2>
            <PillIconButton icon="ui/icon-layer-visualizer-add.png" label="Visualizer" onClick={() => startNewLayer('spectrograph')} />
            <PillIconButton icon="ui/icon-layer-text-add.png" label="Text" onClick={() => startNewLayer('text')} />
            <div style={{ marginLeft: 'auto' }}>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('layers')} aria-label="Toggle layers">
                <img src={assetHref(themedIcon(collapsed.layers ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.layers ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>
          {!collapsed.layers && (
            <div className="section-body">
              {layers.length === 0 && <div className="muted">No layers yet. Add spectrograph or text overlays to render on top of the video.</div>}
              {layers.length > 0 && (
                <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                  {layers.map((layer) => (
                    <div key={layer.id} style={{ display: 'flex', alignItems: 'center', gap: 10, padding: '8px 10px', background: 'var(--panel-alt)', border: '1px solid var(--border)', borderRadius: 8 }}>
                      <div style={{ width: 16, height: 16, borderRadius: 4, background: layer.color }} />
                      <div style={{ flex: 1 }}>
                        <div style={{ fontWeight: 600 }}>{layer.type === 'text' ? 'Text Layer' : 'Spectrograph Layer'}</div>
                        <div className="muted" style={{ fontSize: 12 }}>
                          {layer.type === 'text'
                            ? `Text: ${(layer as any).text ?? ''} @ (${Math.round(layer.x * 100)}%, ${Math.round(layer.y * 100)}%), font ${(layer as any).font ?? ''} ${(layer as any).fontSize ?? ''}`
                            : `Mode: ${(layer as any).mode ?? 'bar'} @ (${Math.round(layer.x * 100)}%, ${Math.round(layer.y * 100)}%)`}
                        </div>
                      </div>
                      <button className="pill-btn" type="button" onClick={() => openEditLayer(layer)}>Edit</button>
                      <button className="pill-btn" type="button" onClick={() => duplicateLayer(layer)}>Duplicate</button>
                      <button className="pill-btn" type="button" onClick={() => deleteLayer(layer.id)}>Delete</button>
                    </div>
                  ))}
                </div>
              )}
              {layerDialogOpen && (
                <div className="panel" style={{ marginTop: 10, padding: 12 }}>
                  <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Type
                      <select
                        value={layerDraft.type ?? 'spectrograph'}
                        onChange={(e) => {
                          const nextType = e.target.value as LayerType;
                          setLayerDraft((prev) => ({
                            ...prev,
                            type: nextType,
                            mode: nextType === 'spectrograph' ? (prev.mode as any) ?? 'bar' : undefined,
                            text: nextType === 'text' ? (prev.text ?? 'Text') : undefined,
                            font: nextType === 'text' ? (prev.font ?? 'Segoe UI') : undefined,
                            fontSize: nextType === 'text' ? (prev.fontSize ?? 12) : undefined,
                          }));
                        }}
                      >
                        <option value="spectrograph">Standard Spectrograph</option>
                        <option value="text">Text</option>
                      </select>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Color
                      <input type="color" value={layerDraft.color ?? '#ffffff'} onChange={(e) => updateLayerDraftField({ color: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Outline Color
                      <input type="color" value={layerDraft.outlineColor ?? '#000000'} onChange={(e) => updateLayerDraftField({ outlineColor: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Outline Width
                      <input type="range" min={0} max={20} value={layerDraft.outlineWidth ?? 0} onChange={(e) => updateLayerDraftField({ outlineWidth: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Outline Width (px)', layerDraft.outlineWidth ?? 0, 0, 20, (v) => updateLayerDraftField({ outlineWidth: v }))}
                      >
                        {layerDraft.outlineWidth ?? 0}px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Glow Color
                      <input type="color" value={layerDraft.glowColor ?? '#ffffff'} onChange={(e) => updateLayerDraftField({ glowColor: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Glow Amount
                      <input type="range" min={0} max={50} value={layerDraft.glowAmount ?? 0} onChange={(e) => updateLayerDraftField({ glowAmount: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Glow Amount (px)', layerDraft.glowAmount ?? 0, 0, 50, (v) => updateLayerDraftField({ glowAmount: v }))}
                      >
                        {layerDraft.glowAmount ?? 0}px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Glow Opacity
                      <input type="range" min={0} max={1} step={0.05} value={layerDraft.glowOpacity ?? 0.4} onChange={(e) => updateLayerDraftField({ glowOpacity: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Glow Opacity (0..1)', layerDraft.glowOpacity ?? 0.4, 0, 1, (v) => updateLayerDraftField({ glowOpacity: v }))}
                      >
                        {(layerDraft.glowOpacity ?? 0.4).toFixed(2)}
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Shadow Color
                      <input type="color" value={layerDraft.shadowColor ?? '#000000'} onChange={(e) => updateLayerDraftField({ shadowColor: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Shadow Distance
                      <input type="range" min={0} max={50} value={layerDraft.shadowDistance ?? 0} onChange={(e) => updateLayerDraftField({ shadowDistance: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Shadow Distance (px)', layerDraft.shadowDistance ?? 0, 0, 50, (v) => updateLayerDraftField({ shadowDistance: v }))}
                      >
                        {layerDraft.shadowDistance ?? 0}px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      X (%)
                      <input type="range" min={-100} max={100} value={Math.round((layerDraft.x ?? 0) * 100)} onChange={(e) => updateLayerDraftField({ x: Math.min(100, Math.max(-100, Number(e.target.value))) / 100 })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('X (%)', Math.round((layerDraft.x ?? 0) * 100), -100, 100, (v) => updateLayerDraftField({ x: v / 100 }))}
                      >
                        {Math.round((layerDraft.x ?? 0) * 100)}%
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Y (%)
                      <input type="range" min={-100} max={100} value={Math.round((layerDraft.y ?? 0) * 100)} onChange={(e) => updateLayerDraftField({ y: Math.min(100, Math.max(-100, Number(e.target.value))) / 100 })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Y (%)', Math.round((layerDraft.y ?? 0) * 100), -100, 100, (v) => updateLayerDraftField({ y: v / 100 }))}
                      >
                        {Math.round((layerDraft.y ?? 0) * 100)}%
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Rotate
                      <input type="range" min={0} max={360} value={Math.round(layerDraft.rotate ?? 0)} onChange={(e) => updateLayerDraftField({ rotate: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Rotate (deg)', Math.round(layerDraft.rotate ?? 0), 0, 360, (v) => updateLayerDraftField({ rotate: v }))}
                      >
                        {Math.round(layerDraft.rotate ?? 0)}deg
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Transparency
                      <input type="range" min={0} max={100} value={Math.round((layerDraft.opacity ?? 1) * 100)} onChange={(e) => updateLayerDraftField({ opacity: Math.min(100, Math.max(0, Number(e.target.value))) / 100 })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Transparency (%)', Math.round((layerDraft.opacity ?? 1) * 100), 0, 100, (v) => updateLayerDraftField({ opacity: v / 100 }))}
                      >
                        {Math.round((layerDraft.opacity ?? 1) * 100)}%
                      </span>
                    </label>
                {layerDraft.type === 'spectrograph' && (
                  <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                    Mode
                    <select value={layerDraft.mode ?? 'bar'} onChange={(e) => updateLayerDraftField({ mode: e.target.value as 'bar' | 'line' | 'solid' | 'dots' })}>
                      <option value="bar">Bar</option>
                      <option value="line">Line</option>
                      <option value="solid">Solid</option>
                      <option value="dots">Dots</option>
                    </select>
                  </label>
                )}
                {layerDraft.type === 'spectrograph' && (
                  <>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Width (px)
                      <input type="range" min={50} max={4000} value={Math.round(layerDraft.width ?? canvasSize.width)} onChange={(e) => updateLayerDraftField({ width: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Width (px)', Math.round(layerDraft.width ?? canvasSize.width), 50, 4000, (v) => updateLayerDraftField({ width: v }))}
                      >
                        {Math.round(layerDraft.width ?? canvasSize.width)} px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Height (px)
                      <input type="range" min={50} max={3000} value={Math.round(layerDraft.height ?? canvasSize.height)} onChange={(e) => updateLayerDraftField({ height: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Height (px)', Math.round(layerDraft.height ?? canvasSize.height), 50, 3000, (v) => updateLayerDraftField({ height: v }))}
                      >
                        {Math.round(layerDraft.height ?? canvasSize.height)} px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Invert
                      <button
                        className="pill-btn"
                        type="button"
                        aria-pressed={!!layerDraft.invert}
                        onClick={() => updateLayerDraftField({ invert: !layerDraft.invert })}
                      >
                        <span>{layerDraft.invert ? 'On' : 'Off'}</span>
                      </button>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Reverse
                      <button
                        className="pill-btn"
                        type="button"
                        aria-pressed={!!layerDraft.reverse}
                        onClick={() => updateLayerDraftField({ reverse: !layerDraft.reverse })}
                      >
                        <span>{layerDraft.reverse ? 'On' : 'Off'}</span>
                      </button>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Low Cut (Hz)
                      <input type="range" min={10} max={500} value={layerDraft.lowCutHz ?? 40} onChange={(e) => updateLayerDraftField({ lowCutHz: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Low Cut (Hz)', layerDraft.lowCutHz ?? 40, 10, 500, (v) => updateLayerDraftField({ lowCutHz: v }))}
                      >
                        {layerDraft.lowCutHz ?? 40} Hz
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      High Cut (Hz)
                      <input type="range" min={2000} max={20000} step={100} value={layerDraft.highCutHz ?? 16000} onChange={(e) => updateLayerDraftField({ highCutHz: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('High Cut (Hz)', layerDraft.highCutHz ?? 16000, 2000, 20000, (v) => updateLayerDraftField({ highCutHz: v }))}
                      >
                        {layerDraft.highCutHz ?? 16000} Hz
                      </span>
                    </label>
                  </>
                )}
                    {layerDraft.type === 'text' && (
                      <>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Text
                          <input type="text" value={layerDraft.text ?? ''} onChange={(e) => updateLayerDraftField({ text: e.target.value })} />
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Font
                          <input
                            type="text"
                            list="layer-font-options"
                            value={layerDraft.font ?? 'Segoe UI'}
                            onChange={(e) => updateLayerDraftField({ font: e.target.value })}
                            placeholder="Select or type a font"
                          />
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Font Size
                          <input type="range" min={8} max={96} value={layerDraft.fontSize ?? 12} onChange={(e) => updateLayerDraftField({ fontSize: Number(e.target.value) })} />
                          <span className="muted" style={{ fontSize: 12 }}>{layerDraft.fontSize ?? 12}px</span>
                        </label>
                      </>
                    )}
                    <datalist id="layer-font-options">
                      {FONT_FACE_OPTIONS.map((name) => (<option value={name} key={name} />))}
                    </datalist>
                  </div>
                  <div style={{ marginTop: 12, display: 'flex', gap: 8 }}>
                    <button type="button" onClick={saveLayerDraft}>OK</button>
                    <button type="button" onClick={() => { setLayerDialogOpen(false); }}>Cancel</button>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Media Library */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>MEDIA LIBRARY</h2>
            <button className="pill-btn" type="button" onClick={() => setAddVideoModalOpen(true)}>
              <span>Add Entry</span>
            </button>
            <button className="pill-btn" type="button" disabled={!librarySelectedId} onClick={async () => {
              if (!librarySelectedId) return;
              const next = library.filter((i) => i.id !== librarySelectedId);
              await saveLibrary(next);
              setLibrarySelectedId(null);
            }}>
              <span>Remove</span>
            </button>
            <div style={{ marginLeft: 'auto' }}>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('library')} aria-label="Toggle library">
                <img src={assetHref(themedIcon(collapsed.library ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.library ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>
          {!collapsed.library && (
            <div className="section-body">
              {library.length === 0 && <div className="muted">No items in library.</div>}
              {library.length > 0 && (
                <>
                  <div style={{ maxHeight: 200, overflow: 'auto', border: '1px solid var(--border)', borderRadius: 6 }}>
                    {library.map((item) => (
                      <div
                        key={item.id}
                        onClick={() => setLibrarySelectedId(item.id)}
                        style={{
                          padding: '6px 8px',
                          cursor: 'pointer',
                          background: missingPaths.has(item.path)
                            ? '#4a2a2a'
                            : (librarySelectedId === item.id ? 'var(--panel-alt)' : 'transparent'),
                          borderBottom: '1px solid var(--border)',
                        }}
                      >
                        <div style={{ fontWeight: 600 }}>{item.name}</div>
                        <div className="muted" style={{ fontSize: 12 }}>{item.path}</div>
                      </div>
                    ))}
                  </div>
                  {librarySelectedId && (() => {
                    const sel = library.find((i) => i.id === librarySelectedId);
                    if (!sel) return null;
                    return (
                      <div style={{ marginTop: 8, padding: 8, border: '1px solid var(--border)', borderRadius: 6 }}>
                        <div style={{ fontWeight: 700, marginBottom: 4 }}>{sel.name}</div>
                        {sel.description && <div className="muted">{sel.description}</div>}
                        <div className="muted" style={{ fontSize: 12 }}>Path: {sel.path}</div>
                        <div className="muted" style={{ fontSize: 12 }}>Duration: {sel.duration ? `${Math.round(sel.duration)}s` : 'n/a'}</div>
                        <div className="muted" style={{ fontSize: 12 }}>Video: {sel.videoCodec ?? 'n/a'} {sel.width && sel.height ? `(${sel.width}x${sel.height})` : ''}</div>
                        <div className="muted" style={{ fontSize: 12 }}>Audio: {sel.audioCodec ?? 'n/a'} {sel.audioChannels ? `(${sel.audioChannels}ch)` : ''}</div>
                      </div>
                    );
                  })()}
                </>
              )}
            </div>
          )}
        </div>



        {addVideoModalOpen && (
          <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}>
            <div style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 8, padding: 16, width: 520, maxHeight: '70vh', overflow: 'auto' }}>
              <h3 style={{ marginTop: 0 }}>Add Video</h3>
              <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap', marginBottom: 12 }}>
                <button className="pill-btn" type="button" onClick={() => { setCollapsed((prev) => ({ ...prev, library: false })); }}>
                  <span>Pick From Library Below</span>
                </button>
                <button className="pill-btn" type="button" onClick={handleBrowseAndAddToLibrary}>
                  <span>Browse Files</span>
                </button>
                <button className="pill-btn" type="button" onClick={() => setAddVideoModalOpen(false)}>
                  <span>Close</span>
                </button>
              </div>
              <div style={{ maxHeight: 300, overflow: 'auto', border: '1px solid var(--border)', borderRadius: 6 }}>
                {library.map((item) => (
                  <div
                    key={item.id}
                    onClick={() => setLibrarySelectedId(item.id)}
                    onDoubleClick={() => handleAddVideoFromLibrary(item)}
                    style={{
                      padding: '6px 8px',
                      cursor: 'pointer',
                      background: librarySelectedId === item.id ? 'var(--panel-alt)' : 'transparent',
                      borderBottom: '1px solid var(--border)',
                    }}
                  >
                    <div style={{ fontWeight: 600 }}>{item.name}</div>
                    <div className="muted" style={{ fontSize: 12 }}>{item.path}</div>
                  </div>
                ))}
              </div>
              <div style={{ display: 'flex', gap: 8, marginTop: 10 }}>
                <button className="pill-btn" type="button" disabled={!librarySelectedId} onClick={() => {
                  const sel = library.find((i) => i.id === librarySelectedId);
                  if (sel) handleAddVideoFromLibrary(sel);
                }}>
                  <span>Use Selected</span>
                </button>
              </div>
            </div>
          </div>
        )}

        {licenseModalOpen && (
          <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1100 }} onClick={() => setLicenseModalOpen(false)}>
            <div style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 10, padding: 18, width: 560, maxWidth: '92vw' }} onClick={(e) => e.stopPropagation()}>
              <h3 style={{ marginTop: 0, marginBottom: 12 }}>Upgrade to Full Version</h3>
              <div style={{ display: 'grid', gridTemplateColumns: '160px 1fr', gap: 16, alignItems: 'center', marginBottom: 12 }}>
                <div style={{ background: '#0c1020', borderRadius: 10, padding: 8, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                  <img
                    src={assetHref('ui/muvidgen_setupWizard_logo.png')}
                    alt="Muvidgen logo"
                    style={{ width: '100%', maxWidth: 190, height: 'auto', display: 'block', objectFit: 'contain' }}
                  />
                </div>
                <div style={{ background: '#f3f4f6', color: '#111', borderRadius: 8, padding: 12, border: '1px solid #e5e7eb' }}>
                  <a href="https://muvidgen.sorryneedboost.com" target="_blank" rel="noopener noreferrer" style={{ textDecoration: 'underline', color: 'inherit', display: 'inline-block', fontFamily: 'Segoe UI, sans-serif' }}>
                    <strong style={{ fontSize: '1.1em', fontWeight: 700, color: '#000' }}>Purchase Here</strong>
                  </a>
                  <div style={{ fontStyle: 'italic', color: '#666', fontSize: '0.85em', marginTop: 6, lineHeight: 1.5, maxWidth: 500 }}>
                    Lifetime license that unlocks all current and future features for this generation of the muVid application.
                  </div>
                </div>
              </div>
              <label style={{ display: 'flex', flexDirection: 'row', gap: 6, marginBottom: 10 }}>
                <span style={{ fontWeight: 600, padding: '5px 10px 10px 10px' }}>Enter Product Key</span>
                <input
                  type="text"
                  value={licenseKeyInput}
                  onChange={(e) => setLicenseKeyInput(e.target.value)}
                  placeholder="XXXX-XXXX-XXXX-XXXX"
                  style={{ padding: '8px 10px', borderRadius: 6, textAlign: 'center', border: '1px solid var(--border)', background: 'var(--panel-alt)', color: 'var(--text)' }}
                />
              </label>
              {licenseError && <div style={{ color: '#c0392b', marginBottom: 10 }}>{licenseError}</div>}
              <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end' }}>
                <button className="pill-btn" type="button" onClick={() => setLicenseModalOpen(false)}>
                  <span>Close</span>
                </button>
                <button className="pill-btn" type="button" onClick={handleValidateLicense} disabled={validatingLicense}>
                  <span>{validatingLicense ? 'Checking...' : 'Activate'}</span>
                </button>
              </div>

            </div>
          </div>
        )}
   <div style={{ opacity: projectLocked ? 0.55 : 1 }}>
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>PROJECT</h2>
                <button className="pill-btn" type="button" onClick={handleNewProject}>
                  <span>New</span>
                </button>
                <PillIconButton icon="ui/icon-project-load.png" label="Load" onClick={handleLoadProject} disabled={projectLocked} title={projectLocked ? 'Available in full version' : undefined} />
                <PillIconButton icon="ui/icon-project-save-as.png" label="Save As" onClick={handleSaveProjectAs} disabled={projectLocked} title={projectLocked ? 'Available in full version' : undefined} />
                <PillIconButton icon="ui/icon-project-save.png" label="Save" onClick={handleSaveProject} disabled={projectLocked} title={projectLocked ? 'Available in full version' : undefined} />
                <button
                  className="pill-btn pill-btn--icon"
                  type="button"
                  aria-label="Landscape"
                  aria-pressed={canvasPreset === 'landscape'}
                  onClick={() => setCanvasPreset('landscape')}
                  style={{ borderColor: canvasPreset === 'landscape' ? 'var(--accent)' : 'var(--border)' }}
                  title="Landscape"
                >
                  <img className="pill-btn__img" src={assetHref('ui/icon-landscape.png')} alt="" />
                </button>
                <button
                  className="pill-btn pill-btn--icon"
                  type="button"
                  aria-label="Portrait"
                  aria-pressed={canvasPreset === 'portrait'}
                  onClick={() => setCanvasPreset('portrait')}
                  style={{ borderColor: canvasPreset === 'portrait' ? 'var(--accent)' : 'var(--border)' }}
                  title="Portrait"
                >
                  <img className="pill-btn__img" src={assetHref('ui/icon-portrait.png')} alt="" />
                </button>
                <button className="pill-btn" type="button" onClick={handleUnlicense} title="Testing only">
                  <span>Unlicense</span>
                </button>

                  <button className="pill-btn" type="button" onClick={() => { setLogs([]); setRenderElapsedMs(0); setRenderTotalMs(0); }}>
                  <span>Clear Logs</span>
                  </button>
                    <span style={{ color: '#666' }}>Elapsed: {Math.floor((renderElapsedMs/1000))}s</span>
                  {renderTotalMs > 0 && (
                    <span style={{ color: '#666' }}>
                      ETA: {Math.max(0, Math.floor((renderTotalMs - renderElapsedMs)/1000))}s
                    </span>
                  )}


              <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'right', gap: 10 }}>
                <PillIconButton icon="ui/icon-sliders.png" label="Render" onClick={handleStartRender} disabled={projectLocked || !session.projectSavePath || isRendering} />
                <PillIconButton icon="ui/icon-x.png" label="Cancel" onClick={() => cancelRender()} disabled={projectLocked || !isRendering} />            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 10 }}>
              </div>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('project')} aria-label="Toggle project">
                <img src={assetHref(themedIcon(collapsed.project ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.project ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>

          {!collapsed.project && (
            <div className="section-body" style={{ position: 'relative' }}>
              {projectLocked && (
                <button
                  type="button"
                  onClick={() => setLicenseModalOpen(true)}
                  style={{
                    position: 'absolute',
                    inset: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    padding: '12px 16px',
                    background: 'rgba(0, 0, 0, 0.65)',
                    color: '#f5f5f5',
                    fontSize: 16,
                    fontWeight: 700,
                    border: '1px dashed var(--border)',
                    borderRadius: 8,
                    cursor: 'pointer',
                    textAlign: 'center',
                    lineHeight: 1.4,
                    zIndex: 2,
                  }}
                >
                  Trial Edition: Click here to upgrade to the Full Version.
                </button>
              )}
           

                {renderTotalMs > 0 && (
                  <div style={{ marginTop: '0.5rem', height: 10, background: '#222', borderRadius: 4, overflow: 'hidden' }}>
                    <div style={{ height: '100%', width: `${Math.min(100, Math.max(0, (renderElapsedMs / renderTotalMs) * 100)).toFixed(1)}%`, background: '#3f51b5' }} />
                  </div>
                )}
                <div style={{ marginTop: '0.5rem', padding: '8px', background: '#0b0b0b', border: '1px solid #333', borderRadius: 4, maxHeight: 200, overflow: 'auto', fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace', fontSize: 12 }}>
                  {logs.length === 0 ? (
                    <div style={{ color: '#777' }}>Render logs will appear here...</div>
                  ) : (
                    logs.map((l, i) => (<div key={i}>{l}</div>))
                  )}
                </div>
              </div>
          
          )}
        </div>
  </div>
        {/* Notes Row (collapsed by default) */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>NOTES</h2>
            <PillIconButton icon="ui/button_notes.svg" label={showNotes ? 'Hide' : 'Show'} onClick={() => setShowNotes((v) => !v)} />
          </div>
          {showNotes && (
            <div className="section-body">
              <textarea
                id="session-notes"
                style={{ display: 'block', width: '100%', minHeight: '200px', marginTop: '0.5rem' }}
                value={String((session as any).notes ?? '')}
                onChange={handleNotesChange}
              />
              <div style={{ marginTop: '1rem', display: 'flex', gap: '0.5rem' }}>
                <button type="button" onClick={handleSave}>Save Session</button>
                <button type="button" onClick={handleExport}>Export Session</button>
              </div>
              {status && <p style={{ color: 'green' }}>{status}</p>}
              {error && (
                <p role="alert" style={{ color: 'red' }}>
                  {error}
                </p>
              )}
            </div>
          )}
        </div>
      </div>

      {contextMenu && (
        <div style={{ position: 'fixed', inset: 0, zIndex: 1100 }} onClick={closeContextMenu}>
          <div
            style={{
              position: 'absolute',
              top: contextMenu.y,
              left: contextMenu.x,
              background: 'var(--panel)',
              border: '1px solid var(--border)',
              borderRadius: 8,
              padding: 6,
              minWidth: 160,
              boxShadow: '0 8px 20px rgba(0,0,0,0.4)',
            }}
            onClick={(e) => e.stopPropagation()}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => startRenameClip(contextMenu.path, contextMenu.index)}>Rename</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => handleClipEdit(contextMenu.path)}>Edit</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => handleClipAddToLibrary(contextMenu.path)}>Add to Library</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => duplicateClipAt(contextMenu.index)}>Duplicate</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => handleClipInfo(contextMenu.path)}>File Info</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => removeClipAt(contextMenu.index)}>Remove</button>
            </div>
          </div>
        </div>
      )}

      {renameTarget && (
        <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', zIndex: 1200, display: 'flex', alignItems: 'center', justifyContent: 'center' }} onClick={() => setRenameTarget(null)}>
          <div style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 8, padding: 16, width: 360 }} onClick={(e) => e.stopPropagation()}>
            <h3 style={{ marginTop: 0 }}>Rename Clip</h3>
            <input
              type="text"
              style={{ width: '100%', marginBottom: 10 }}
              value={renameTarget.name}
              onChange={(e) => setRenameTarget((prev) => (prev ? { ...prev, name: e.target.value } : prev))}
            />
            <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end' }}>
              <button className="pill-btn" type="button" onClick={() => setRenameTarget(null)}>Cancel</button>
              <button className="pill-btn" type="button" onClick={applyRenameClip}>Save</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default App;
