import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import type { ChangeEvent } from 'react';
import {
  exportSession,
  loadSessionState,
  saveSessionState,
  openAudioFile,
  openVideoFiles,
  openImageFile,
  readFileBuffer,
  chooseProjectSavePath,
  startRender,
  cancelRender,
  onRenderLog,
  onRenderProgress,
  onRenderDone,
  onRenderError,
  onRenderCancelled,
  openProject,
  updateProjectDirty,
  onProjectRequestSave,
  notifyProjectSaved,
  chooseRenderOutput,
  prepareRenderProject,
  getDefaultProjectPath,
  saveProject,
  loadMediaLibrary,
  saveMediaLibrary as persistMediaLibrary,
  probeMediaFile,
  fileExists,
} from './state/storage';
import type { SessionState } from './types/session';
// ProjectSchema usage comes via storage types; no direct import needed here.
import Waveform from './components/Waveform';
import type { WaveformHandle } from './components/Waveform';
import OverviewWaveform from './components/OverviewWaveform';
import Storyboard from './components/Storyboard';
import VolumeSlider from './components/VolumeSlider';
import type { ProjectSchema, LayerConfig, LayerType } from 'common/project';
import type { MediaLibraryItem } from 'common/project';
import { base64UrlDecode } from './utils/b64';

type Theme = 'dark' | 'light';
type WebAudioWindow = Window & { webkitAudioContext?: typeof AudioContext };

type LocalSession = SessionState & {
  audioPath?: string;
  videoPaths?: string[];
  videoIds?: string[];
  clipEdits?: Record<string, ClipEdit>;
  projectSavePath?: string;
  playhead?: number;
  layers?: LayerConfig[];
  theme?: Theme;
  canvasPreset?: 'landscape' | 'portrait';
  videoNames?: Record<string, string>;
};

const defaultState: LocalSession = { notes: '', playhead: 0, theme: 'dark', canvasPreset: 'landscape', videoNames: {}, videoIds: [], clipEdits: {} };
type LicensePayload = { name?: string; email?: string; edition?: string; issuedAt?: number; expiresAt?: number };
const FONT_FACE_OPTIONS = [
  'Segoe UI',
  'Laritza',
  'Explosion',
  'Explosion-3D',
  'Explosion-Outlined',
  'Explosion-Outlined-3D',
  'Failed',
  'Failed-3D',
  'Failed-3D-Italic',
  'Failed-Italic',
  'Esprit',
  'Essen',
  'Essen3D',
  'Essen-Bold',
  'Essen-Italic',
  'Essere',
  'Essere-Italic',
];

const LICENSE_PUBLIC_KEY_JWK: JsonWebKey = {
  // TODO: replace with your real public key (P-256 / ECDSA) generated by tools/license/sign-license.js.
  "kty": "EC",
  "x": "2wFqyi88_EgpFcQWEzF9aG2knDq39E0iXDKus4yViB4",
  "y": "w1x271OSPw0N9VAEyq9qScubK-66-_dcw8lvh8FQma8",
  "crv": "P-256"
};

const base64UrlToUint8 = (input: string): Uint8Array => {
  const normalized = input.replace(/-/g, '+').replace(/_/g, '/');
  const pad = normalized.length % 4 === 2 ? '==' : normalized.length % 4 === 3 ? '=' : '';
  const b64 = normalized + pad;
  const globalBuffer = typeof globalThis !== 'undefined' ? (globalThis as any).Buffer : undefined;
  const binary = typeof atob === 'function'
    ? atob(b64)
    : (globalBuffer
      ? globalBuffer.from(b64, 'base64').toString('binary')
      : (() => { throw new Error('No base64 decoder available'); })());
  const out = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) out[i] = binary.charCodeAt(i);
  return out;
};

const readDerLength = (bytes: Uint8Array, start: number) => {
  if (start >= bytes.length) return null;
  let len = bytes[start];
  let offset = start + 1;
  if (len & 0x80) {
    const count = len & 0x7f;
    if (count === 0 || count > 2 || offset + count > bytes.length) return null;
    len = 0;
    for (let i = 0; i < count; i++) {
      len = (len << 8) | bytes[offset++];
    }
  }
  return { len, offset };
};

const derToRawEcdsa = (derSig: Uint8Array, size: number): Uint8Array | null => {
  if (derSig.length < 8 || derSig[0] !== 0x30) return null;
  const seq = readDerLength(derSig, 1);
  if (!seq) return null;
  let idx = seq.offset;
  if (idx + seq.len !== derSig.length) return null;
  if (derSig[idx++] !== 0x02) return null;
  const rLenInfo = readDerLength(derSig, idx);
  if (!rLenInfo) return null;
  idx = rLenInfo.offset;
  const rStart = idx;
  const rEnd = rStart + rLenInfo.len;
  if (rEnd > derSig.length) return null;
  let r = derSig.slice(rStart, rEnd);
  idx = rEnd;
  if (derSig[idx++] !== 0x02) return null;
  const sLenInfo = readDerLength(derSig, idx);
  if (!sLenInfo) return null;
  idx = sLenInfo.offset;
  const sStart = idx;
  const sEnd = sStart + sLenInfo.len;
  if (sEnd > derSig.length) return null;
  let s = derSig.slice(sStart, sEnd);
  if (idx + sLenInfo.len !== derSig.length) return null;
  while (r.length > size && r[0] === 0x00) r = r.slice(1);
  while (s.length > size && s[0] === 0x00) s = s.slice(1);
  if (r.length > size || s.length > size) return null;
  const out = new Uint8Array(size * 2);
  out.set(r, size - r.length);
  out.set(s, size + (size - s.length));
  return out;
};

const getSubtle = () => {
  const c = typeof crypto !== 'undefined' ? crypto : (typeof window !== 'undefined' ? (window as any).crypto : undefined);
  if (!c) return null;
  if ((c as any).subtle) return (c as any).subtle;
  if ((c as any).webkitSubtle) return (c as any).webkitSubtle;
  return null;
};

let cachedLicenseKey: CryptoKey | null = null;
const importLicensePublicKey = async () => {
  try {
    if (cachedLicenseKey) return cachedLicenseKey;
    if (!LICENSE_PUBLIC_KEY_JWK.x || !LICENSE_PUBLIC_KEY_JWK.y) return null;
    const subtle = getSubtle();
    if (!subtle) return null;
    cachedLicenseKey = await subtle.importKey(
      'jwk',
      LICENSE_PUBLIC_KEY_JWK,
      { name: 'ECDSA', namedCurve: 'P-256' },
      false,
      ['verify'],
    );
    return cachedLicenseKey;
  } catch (err) {
    console.warn('License public key import failed', err);
    return null;
  }
};

const parseLicensePayload = (bytes: Uint8Array): LicensePayload | null => {
  try {
    const text = new TextDecoder().decode(bytes);
    const json = JSON.parse(text);
    if (json && typeof json === 'object') return json as LicensePayload;
  } catch (err) {
    console.warn('Failed to parse license payload', err);
  }
  return null;
};

const App = () => {
  const [session, setSession] = useState<LocalSession>(defaultState);
  const [status, setStatus] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  const [logs, setLogs] = useState<string[]>([]);
  const [renderElapsedMs, setRenderElapsedMs] = useState<number>(0);
  const [renderTotalMs, setRenderTotalMs] = useState<number>(0);
  const [isRendering, setIsRendering] = useState<boolean>(false);
  const [audioDuration, setAudioDuration] = useState<number>(0);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [showNotes, setShowNotes] = useState<boolean>(false);
  const [videoDurations, setVideoDurations] = useState<Record<string, number>>({});
  const [theme, setThemeChoice] = useState<Theme>('dark');
  const [canvasPreset, setCanvasPreset] = useState<'landscape' | 'portrait'>('landscape');
  const [overviewPeaks, setOverviewPeaks] = useState<number[]>([]);
  const [volume, setVolume] = useState<number>(0.85);
  const waveRef = useRef<WaveformHandle | null>(null);
  const [layerDialogOpen, setLayerDialogOpen] = useState<boolean>(false);
  const [layerDraft, setLayerDraft] = useState<LayerDraft>({});
  const [timelineZoom, setTimelineZoom] = useState<number>(1);
  const [timelineScroll, setTimelineScroll] = useState<number>(0);
  const layers = useMemo(() => session.layers ?? [], [session.layers]);
  const canvasSize = useMemo(() => (
    canvasPreset === 'portrait'
      ? { width: 1080, height: 1920 }
      : { width: 1920, height: 1080 }
  ), [canvasPreset]);
  const previewCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const videoPoolRef = useRef<Map<string, HTMLVideoElement>>(new Map());
  const imagePoolRef = useRef<Map<string, HTMLImageElement>>(new Map());
  const [audioEl, setAudioEl] = useState<HTMLAudioElement | null>(null);
  const audioMotionRef = useRef<any>(null);
  const spectroAudioCtxRef = useRef<AudioContext | null>(null);
  const spectroSourceRef = useRef<MediaElementAudioSourceNode | null>(null);
  const spectroAnalyserRef = useRef<AnalyserNode | null>(null);
  const spectroGainRef = useRef<GainNode | null>(null);
  const spectroLastDataRef = useRef<Uint8Array | null>(null);
  const previewBusyRef = useRef<boolean>(false);
  const previewQueuedRef = useRef<boolean>(false);
  const spectroCacheRef = useRef<HTMLCanvasElement | null>(null);
  const spectroWorkRef = useRef<HTMLCanvasElement | null>(null);
  const particleStateRef = useRef<Map<string, ParticleState>>(new Map());
  const USE_AUDIO_MOTION = false;
  const [library, setLibrary] = useState<MediaLibraryItem[]>([]);
  const [librarySelectedId, setLibrarySelectedId] = useState<string | null>(null);
  const [addVideoModalOpen, setAddVideoModalOpen] = useState<boolean>(false);
  const [missingPaths, setMissingPaths] = useState<Set<string>>(new Set());
  const [contextMenu, setContextMenu] = useState<{ id: string; path: string; index: number; x: number; y: number } | null>(null);
  const [renameTarget, setRenameTarget] = useState<{ path: string; index: number; name: string } | null>(null);
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({
    preview: true,
    audio: false,
    videos: false,
    layers: false,
    project: false,
    library: false,
  });
  const [licenseStatus, setLicenseStatus] = useState<{ licensed: boolean; key?: string }>(() => {
    try {
      const raw = localStorage.getItem('muvidgen:license');
      if (raw) {
        const parsed = JSON.parse(raw) as { licensed?: boolean; key?: string };
        return { licensed: !!parsed.licensed, key: parsed.key };
      }
    } catch {}
    return { licensed: false, key: '' };
  });
  const [licenseModalOpen, setLicenseModalOpen] = useState(false);
  const [licenseKeyInput, setLicenseKeyInput] = useState('');
  const [licenseError, setLicenseError] = useState<string | null>(null);
  const [validatingLicense, setValidatingLicense] = useState(false);
  const isLicensed = licenseStatus.licensed;
  const getMaxVideoWidth = useCallback(() => {
    let max = 0;
    videoPoolRef.current.forEach((v) => {
      if (v.videoWidth && v.videoWidth > max) max = v.videoWidth;
    });
    return max || 640;
  }, []);

  const loadLibrary = useCallback(async () => {
    try {
      const items = await loadMediaLibrary();
      setLibrary(items);
    } catch (err) {
      console.warn('Failed to load media library', err);
    }
  }, []);

  const assetHref = (rel: string) => {
    try {
      return new URL(rel, document.baseURI).toString();
    } catch {
      return rel;
    }
  };
  const themedIcon = (rel: string) => {
    if (theme === 'light') {
      const dot = rel.lastIndexOf('.');
      if (dot > 0) {
        const base = rel.slice(0, dot);
        const ext = rel.slice(dot);
        return `${base}-light${ext}`;
      }
    }
    return rel;
  };
  const PillIconButton = ({ icon, label, ...rest }: { icon: string; label: string } & React.ButtonHTMLAttributes<HTMLButtonElement>) => (
    <button className="pill-btn" type="button" {...rest}>
      <img className="pill-btn__img" src={assetHref(icon)} alt="" />
      <span className="pill-btn__label">{label}</span>
    </button>
  );
  const makeId = () => {
    try {
      if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') return crypto.randomUUID();
    } catch {}
    return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  };
  const hexToRgba = (hex: string, alpha: number) => {
    let c = hex.trim();
    if (c.startsWith('#')) c = c.slice(1);
    if (c.length === 3) {
      c = c.split('').map((ch) => ch + ch).join('');
    }
    if (c.length !== 6) return `rgba(255,255,255,${alpha})`;
    const r = parseInt(c.slice(0, 2), 16);
    const g = parseInt(c.slice(2, 4), 16);
    const b = parseInt(c.slice(4, 6), 16);
    return `rgba(${r},${g},${b},${alpha})`;
  };

  const makePseudoPeaks = useCallback((key: string, buckets = 640) => {
    const peaks: number[] = [];
    let seed = 2166136261;
    for (let i = 0; i < key.length; i++) {
      seed ^= key.charCodeAt(i);
      seed += (seed << 1) + (seed << 4) + (seed << 7) + (seed << 8) + (seed << 24);
    }
    const rand = () => {
      seed ^= seed << 13;
      seed ^= seed >>> 17;
      seed ^= seed << 5;
      return ((seed >>> 0) % 1000) / 1000;
    };
    for (let i = 0; i < buckets; i++) {
      const base = 0.35 + rand() * 0.45;
      // slight smoothing with neighbors
      const prev = i > 0 ? peaks[i - 1] : base;
      peaks.push((base * 0.7) + (prev * 0.3));
    }
    return peaks;
  }, []);
  
  const toFileURL = (absPath: string): string => {
    if (/^file:\/\//i.test(absPath)) return absPath;
    if (/^\\\\/.test(absPath)) {
      const withoutPrefix = absPath.replace(/^\\\\+/, '');
      const normalized = withoutPrefix.replace(/\\/g, '/');
      return 'file://' + encodeURI(normalized);
    }
    const normalized = absPath.replace(/\\/g, '/');
    if (/^[A-Za-z]:\//.test(normalized)) {
      return 'file:///' + encodeURI(normalized);
    }
    if (normalized.startsWith('/')) {
      return 'file:///' + encodeURI(normalized);
    }
    return 'file:///' + encodeURI(normalized.startsWith('/') ? normalized.slice(1) : normalized);
  };
  
  const applyTheme = useCallback((name: Theme) => {
    try {
      localStorage.setItem('muvidgen:theme', name);
    } catch {}
    document.documentElement.setAttribute('data-theme', name);
  }, []);

  useEffect(() => {
    try {
      const saved = localStorage.getItem('muvidgen:theme');
      if (saved === 'light' || saved === 'dark') {
        setThemeChoice(saved);
        return;
      }
    } catch {}
    applyTheme('dark');
  }, [applyTheme]);

  useEffect(() => {
    applyTheme(theme);
  }, [applyTheme, theme]);

  useEffect(() => {
    try {
      localStorage.setItem('muvidgen:license', JSON.stringify(licenseStatus));
    } catch {}
  }, [licenseStatus]);

  useEffect(() => {
    if (licenseModalOpen) {
      setLicenseKeyInput(licenseStatus.key ?? '');
      setLicenseError(null);
    }
  }, [licenseModalOpen, licenseStatus.key]);

  useEffect(() => {
    void loadLibrary();
  }, [loadLibrary]);

  // Check missing media (audio, videos, library) when paths change
  useEffect(() => {
    const checkMissing = async () => {
      const targets = new Set<string>();
      if (session.audioPath) targets.add(session.audioPath);
      (session.videoPaths ?? []).forEach((p) => targets.add(p));
      library.forEach((item) => targets.add(item.path));
      const results = await Promise.all(
        Array.from(targets).map(async (p) => ({ p, ok: await fileExists(p) }))
      );
      const missing = results.filter((r) => !r.ok).map((r) => r.p);
      setMissingPaths(new Set(missing));
    };
    void checkMissing();
  }, [session.audioPath, session.videoPaths, library]);

  // Sync theme from session load
  useEffect(() => {
    if (session.theme === 'light' || session.theme === 'dark') {
      setThemeChoice(session.theme);
    }
  }, [session.theme]);

  // Sync canvas preset from session load
  useEffect(() => {
    if (session.canvasPreset === 'portrait' || session.canvasPreset === 'landscape') {
      setCanvasPreset(session.canvasPreset);
    }
  }, [session.canvasPreset]);

  // Persist theme into session for project-level saves
  useEffect(() => {
    setSession((prev) => (prev.theme === theme ? prev : { ...prev, theme }));
  }, [theme]);

  // Persist canvas preset into session for project-level saves
  useEffect(() => {
    setSession((prev) => (prev.canvasPreset === canvasPreset ? prev : { ...prev, canvasPreset }));
  }, [canvasPreset]);

  // Auto-expand preview when media or layers are present
  useEffect(() => {
    const hasMedia = (session.videoPaths?.length ?? 0) > 0 || (session.layers?.length ?? 0) > 0;
    if (hasMedia) {
      setCollapsed((prev) => (prev.preview ? { ...prev, preview: false } : prev));
    }
  }, [session.videoPaths, session.layers]);

  useEffect(() => {
    // Reset zoom/scroll when audio loads
    if (audioDuration > 0) {
      setTimelineZoom(1);
      setTimelineScroll(0);
    }
  }, [audioDuration]);

  const startNewLayer = (type: LayerType) => {
    const baseWidth = canvasSize.width;
    const newId = makeId();
    setLayerDraft({
      id: newId,
      type,
      color: '#ffffff',
      x: 0.05,
      y: 0.05,
      rotate: 0,
      opacity: 1,
      reverse: false,
      width: type === 'image' ? 320 : baseWidth,
      height: type === 'image' ? 320 : Math.round(baseWidth * (canvasSize.height / canvasSize.width)),
      lowCutHz: 40,
      highCutHz: 16000,
      mode: type === 'spectrograph' ? 'bar' : undefined,
      invert: type === 'spectrograph' ? false : undefined,
      barCount: type === 'spectrograph' ? 96 : undefined,
      barWidthPct: type === 'spectrograph' ? 0.8 : undefined,
      dotCount: type === 'spectrograph' ? 96 : undefined,
      solidPointCount: type === 'spectrograph' ? 96 : undefined,
      pathMode: type === 'spectrograph' ? 'straight' : undefined,
      freqScale: type === 'spectrograph' ? 'log' : undefined,
      ampScale: type === 'spectrograph' ? 'log' : undefined,
      averaging: type === 'spectrograph' ? 2 : undefined,
      mirrorX: type === 'spectrograph' ? false : undefined,
      mirrorY: type === 'spectrograph' ? false : undefined,
      imagePath: type === 'image' ? '' : undefined,
      motionAffected: type === 'image' ? true : undefined,
      direction: type === 'particles' ? 0 : undefined,
      speed: type === 'particles' ? 60 : undefined,
      sizeMin: type === 'particles' ? 2 : undefined,
      sizeMax: type === 'particles' ? 6 : undefined,
      opacityMin: type === 'particles' ? 0.3 : undefined,
      opacityMax: type === 'particles' ? 0.9 : undefined,
      audioResponsive: type === 'particles' ? true : undefined,
      particleCount: type === 'particles' ? 200 : undefined,
      text: type === 'text' ? 'Text' : undefined,
      font: type === 'text' ? 'Segoe UI' : undefined,
      fontSize: type === 'text' ? 12 : undefined,
    });
    setSelectedLayerId(newId);
    setLayerDialogOpen(true);
  };

  const openEditLayer = (layer: LayerConfig) => {
    setLayerDraft({ ...layer });
    setSelectedLayerId(layer.id);
    setLayerDialogOpen(true);
  };

  const normalizeLayerDraft = (draft: Partial<LayerConfig>): LayerConfig | null => {
    if (!draft.type || !draft.id) return null;
    const normalized: LayerConfig = { ...(draft as LayerConfig) };
    if (normalized.type === 'spectrograph') {
      normalized.mode = normalized.mode === 'line' || normalized.mode === 'solid' || normalized.mode === 'dots' ? normalized.mode : 'bar';
      if (!normalized.width || !normalized.height) {
        const w = canvasSize.width;
        normalized.width = w;
        normalized.height = Math.round(w * (canvasSize.height / canvasSize.width));
      }
      normalized.opacity = Number.isFinite(normalized.opacity as number) ? normalized.opacity : 1;
      normalized.rotate = Number.isFinite(normalized.rotate as number) ? normalized.rotate : 0;
      normalized.reverse = !!normalized.reverse;
      normalized.invert = !!normalized.invert;
      normalized.barCount = Number.isFinite(normalized.barCount as number) ? Math.max(8, Number(normalized.barCount)) : 96;
      normalized.barWidthPct = Number.isFinite(normalized.barWidthPct as number) ? Math.min(1, Math.max(0.1, Number(normalized.barWidthPct))) : 0.8;
      normalized.dotCount = Number.isFinite(normalized.dotCount as number) ? Math.max(8, Number(normalized.dotCount)) : 96;
      normalized.solidPointCount = Number.isFinite(normalized.solidPointCount as number) ? Math.max(8, Number(normalized.solidPointCount)) : 96;
      normalized.pathMode = normalized.pathMode === 'circular' ? 'circular' : 'straight';
      normalized.freqScale = normalized.freqScale === 'rlog' ? 'rlog' : normalized.freqScale === 'lin' ? 'lin' : 'log';
      normalized.ampScale = normalized.ampScale === 'sqrt' || normalized.ampScale === 'cbrt' || normalized.ampScale === 'lin' ? normalized.ampScale : 'log';
      normalized.averaging = Number.isFinite(normalized.averaging as number) ? Math.max(1, Math.round(Number(normalized.averaging))) : 2;
      normalized.mirrorX = !!normalized.mirrorX;
      normalized.mirrorY = !!normalized.mirrorY;
      normalized.lowCutHz = Number.isFinite(normalized.lowCutHz as number) ? normalized.lowCutHz : 40;
      normalized.highCutHz = Number.isFinite(normalized.highCutHz as number) ? normalized.highCutHz : 16000;
    } else if (normalized.type === 'image') {
      normalized.imagePath = normalized.imagePath ?? '';
      normalized.opacity = Number.isFinite(normalized.opacity as number) ? normalized.opacity : 1;
      normalized.rotate = Number.isFinite(normalized.rotate as number) ? normalized.rotate : 0;
      normalized.reverse = !!normalized.reverse;
      normalized.invert = !!normalized.invert;
      normalized.width = Number.isFinite(normalized.width as number) ? Math.max(20, Number(normalized.width)) : 320;
      normalized.height = Number.isFinite(normalized.height as number) ? Math.max(20, Number(normalized.height)) : 320;
      normalized.outlineWidth = Number.isFinite(normalized.outlineWidth as number) ? Math.max(0, Number(normalized.outlineWidth)) : 0;
      normalized.glowAmount = Number.isFinite(normalized.glowAmount as number) ? Math.max(0, Number(normalized.glowAmount)) : 0;
      normalized.glowOpacity = Number.isFinite(normalized.glowOpacity as number) ? Math.min(1, Math.max(0, Number(normalized.glowOpacity))) : 0.4;
      normalized.shadowDistance = Number.isFinite(normalized.shadowDistance as number) ? Math.max(0, Number(normalized.shadowDistance)) : 0;
      normalized.motionAffected = typeof normalized.motionAffected === 'boolean' ? normalized.motionAffected : true;
    } else if (normalized.type === 'particles') {
      normalized.opacity = Number.isFinite(normalized.opacity as number) ? normalized.opacity : 1;
      normalized.rotate = Number.isFinite(normalized.rotate as number) ? normalized.rotate : 0;
      normalized.reverse = !!normalized.reverse;
      normalized.direction = Number.isFinite(normalized.direction as number) ? Number(normalized.direction) : 0;
      normalized.speed = Number.isFinite(normalized.speed as number) ? Math.max(0, Number(normalized.speed)) : 60;
      normalized.sizeMin = Number.isFinite(normalized.sizeMin as number) ? Math.max(1, Number(normalized.sizeMin)) : 2;
      normalized.sizeMax = Number.isFinite(normalized.sizeMax as number) ? Math.max(normalized.sizeMin ?? 2, Number(normalized.sizeMax)) : 6;
      normalized.opacityMin = Number.isFinite(normalized.opacityMin as number) ? Math.min(1, Math.max(0, Number(normalized.opacityMin))) : 0.3;
      normalized.opacityMax = Number.isFinite(normalized.opacityMax as number) ? Math.min(1, Math.max(normalized.opacityMin ?? 0.3, Number(normalized.opacityMax))) : 0.9;
      normalized.audioResponsive = typeof normalized.audioResponsive === 'boolean' ? normalized.audioResponsive : true;
      normalized.particleCount = Number.isFinite(normalized.particleCount as number) ? Math.max(10, Number(normalized.particleCount)) : 200;
    } else if (normalized.type === 'text') {
      normalized.text = normalized.text ?? 'Text';
      normalized.font = normalized.font ?? 'Segoe UI';
      normalized.fontSize = Number(normalized.fontSize ?? 12);
      normalized.opacity = Number.isFinite(normalized.opacity as number) ? normalized.opacity : 1;
      normalized.rotate = Number.isFinite(normalized.rotate as number) ? normalized.rotate : 0;
      normalized.reverse = !!normalized.reverse;
    }
    return normalized;
  };

  const updateLayerDraftField = (partial: Partial<LayerConfig>) => {
    setLayerDraft((prev) => {
      const next = { ...prev, ...partial };
      const normalized = normalizeLayerDraft(next);
      if (normalized) {
        setSession((prevSession) => {
          const existing = prevSession.layers ?? [];
          const idx = existing.findIndex((l) => l.id === normalized.id);
          const newLayers = existing.slice();
          if (idx >= 0) newLayers[idx] = normalized;
          else newLayers.push(normalized);
          return { ...prevSession, layers: newLayers };
        });
        void updateProjectDirty(true);
        void renderPreviewFrame();
      }
      return next;
    });
  };

  const saveLayerDraft = () => {
    const normalized = normalizeLayerDraft(layerDraft);
    if (!normalized) return;
    setSession((prev) => {
      const existing = prev.layers ?? [];
      const idx = existing.findIndex((l) => l.id === normalized.id);
      const next = existing.slice();
      if (idx >= 0) next[idx] = normalized;
      else next.push(normalized);
      return { ...prev, layers: next };
    });
    setLayerDialogOpen(false);
    void updateProjectDirty(true);
    void renderPreviewFrame();
  };

  const deleteLayer = (id: string) => {
    setSession((prev) => ({ ...prev, layers: (prev.layers ?? []).filter((l) => l.id !== id) }));
    if (selectedLayerId === id) {
      setSelectedLayerId(null);
      setLayerDialogOpen(false);
      setLayerDraft({});
    }
    void updateProjectDirty(true);
  };

  const duplicateLayer = (layer: LayerConfig) => {
    const next = { ...layer, id: makeId(), x: Math.min(1, (layer.x ?? 0) + 0.02), y: Math.min(1, (layer.y ?? 0) + 0.02) };
    setSession((prev) => ({ ...prev, layers: [...(prev.layers ?? []), next] }));
    void updateProjectDirty(true);
  };

  const saveLibrary = async (items: MediaLibraryItem[]) => {
    console.info('[library] saveLibrary', { count: items.length });
    setLibrary(items);
    try {
      await persistMediaLibrary(items);
      console.info('[library] persisted to disk');
    } catch (err) {
      console.warn('Failed to save media library', err);
    }
  };

  const updateLibraryName = async (path: string, nextName: string) => {
    const next = library.map((i) => (i.path === path ? { ...i, name: nextName } : i));
    setLibrary(next);
    await saveLibrary(next);
  };

  const addLibraryEntryFromPath = async (filePath: string, name: string) => {
    console.info('[library] addLibraryEntryFromPath', filePath);
    let meta: Partial<MediaLibraryItem> = {};
    try {
      meta = await probeMediaFile(filePath);
    } catch (err) {
      console.warn('Probe failed; adding without metadata', err);
    }
    const item: MediaLibraryItem = {
      id: makeId(),
      name: name.trim(),
      path: filePath,
      description: '',
      duration: meta.duration ? Number(meta.duration) : undefined,
      videoCodec: meta.videoCodec,
      audioCodec: meta.audioCodec,
      audioChannels: meta.audioChannels ? Number(meta.audioChannels) : undefined,
      width: meta.width ? Number(meta.width) : undefined,
      height: meta.height ? Number(meta.height) : undefined,
    };
    await saveLibrary([...library, item]);
    console.info('[library] added item', item);
    return item;
  };

  // Manage hidden video elements for preview
  useEffect(() => {
    const pool = videoPoolRef.current;
    const keep = new Set(session.videoPaths ?? []);
    // remove stale
    for (const key of Array.from(pool.keys())) {
      if (!keep.has(key)) {
        const vid = pool.get(key)!;
        vid.pause();
        pool.delete(key);
      }
    }
    // add new
    for (const p of keep) {
      if (!pool.has(p)) {
        const v = document.createElement('video');
        v.preload = 'metadata';
        v.crossOrigin = 'anonymous';
        v.src = toFileURL(p);
        pool.set(p, v);
      }
    }
  }, [session.videoPaths]);

  useEffect(() => {
    const pool = imagePoolRef.current;
    const imagePaths = new Set(
      (session.layers ?? [])
        .filter((layer) => layer.type === 'image')
        .map((layer) => (layer as any).imagePath)
        .filter(Boolean)
    );
    for (const key of Array.from(pool.keys())) {
      if (!imagePaths.has(key)) {
        pool.delete(key);
      }
    }
    for (const p of imagePaths) {
      if (!pool.has(p)) {
        const img = new Image();
        img.src = toFileURL(p);
        pool.set(p, img);
      }
    }
  }, [session.layers]);


  useEffect(() => {
    // Load session
    let cancelled = false;
    loadSessionState()
      .then((state) => {
        if (!cancelled && state) setSession({ ...(state as any), playhead: 0 });
      })
      .catch((err: unknown) => setError(err instanceof Error ? err.message : String(err)));

    // Wire render event listeners
    const offLog = onRenderLog((line) => setLogs((prev) => [...prev, line]));
    const offProgress = onRenderProgress(({ outTimeMs, totalMs }) => {
      if (typeof outTimeMs === 'number') setRenderElapsedMs(outTimeMs);
      if (typeof totalMs === 'number') setRenderTotalMs(totalMs);
    });
    const offDone = onRenderDone(() => {
      setIsRendering(false);
      setStatus('Render completed');
    });
    const offErr = onRenderError((msg) => {
      setIsRendering(false);
      setError(msg);
    });
    const offCancelled = onRenderCancelled(() => {
      setIsRendering(false);
      setStatus('Render cancelled');
    });

    // Handle external save requests (e.g., Ctrl+S from host)
    const offReqSave = onProjectRequestSave(() => {
      void handleSaveProject();
    });
    const offMenu = onMenuAction((action) => {
      switch (action) {
        case 'project:new':
          handleNewProject();
          break;
        case 'project:open':
          void handleLoadProject();
          break;
        case 'project:save':
          void handleSaveProject();
          break;
        case 'project:saveAs':
          void handleSaveProjectAs();
          break;
        case 'render:start':
          void handleStartRender();
          break;
        case 'render:cancel':
          void cancelRender();
          break;
        case 'media:loadAudio':
          void handleBrowseAudio();
          break;
        case 'media:addVideos':
          void handleBrowseVideos();
          break;
        case 'media:addFromLibrary':
          setAddVideoModalOpen(true);
          setCollapsed((prev) => ({ ...prev, library: false }));
          break;
        case 'layer:addSpectrograph':
          startNewLayer('spectrograph');
          break;
        case 'layer:addText':
          startNewLayer('text');
          break;
        case 'view:zoomIn':
          setTimelineZoom((z) => Math.min(8, z * 2));
          setTimelineScroll(0);
          break;
        case 'view:zoomOut':
          setTimelineZoom((z) => Math.max(0.25, z / 2));
          setTimelineScroll(0);
          break;
        case 'view:zoomFit':
          setTimelineZoom(1);
          setTimelineScroll(0);
          break;
        case 'help:about':
          setStatus('muvid - music visualizer generator');
          break;
        default:
          break;
      }
    });

    // Cleanup only (not JSX)
    return () => {
      cancelled = true;
      offLog?.();
      offProgress?.();
      offDone?.();
      offErr?.();
      offCancelled?.();
      offReqSave?.();
      offMenu?.();
    };
  }, []);

  const handleBrowseAudio = async () => {
    try {
      const path = await openAudioFile();
      if (path) {
        setSession((prev) => ({ ...prev, audioPath: path, playhead: 0 }));
        setAudioDuration(0);
        setStatus('Audio selected');
        void updateProjectDirty(true);
      }
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleBrowseVideos = async () => {
    try {
      const paths = await openVideoFiles();
      if (!paths || paths.length === 0) return;
      setSession((prev) => {
        const existing = prev.videoPaths ?? [];
        const existingIds = prev.videoIds ?? [];
        const nextNames = { ...(prev.videoNames ?? {}) };
        const nextIds = [...existingIds];
        paths.forEach(() => nextIds.push(makeId()));
        return { ...prev, videoPaths: [...existing, ...paths], videoIds: nextIds, videoNames: nextNames };
      });
      setStatus(`${paths.length} video file(s) added`);
      void updateProjectDirty(true);
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const getClipName = (filePath: string) => {
    const suggested = filePath.split(/[\\/]/).pop() || 'Clip';
    if (typeof window !== 'undefined' && typeof window.prompt === 'function') {
      try {
        const res = window.prompt('Enter clip name (required)', suggested);
        const trimmed = (res ?? suggested).trim();
        if (trimmed) return trimmed;
      } catch (err) {
        console.warn('[library] prompt failed, using filename', err);
      }
    }
    return suggested;
  };

  const promptNumeric = (label: string, value: number, min: number | null, max: number | null, onApply: (next: number) => void) => {
    if (typeof window === 'undefined' || typeof window.prompt !== 'function') return;
    const res = window.prompt(`Enter ${label}`, String(value));
    if (res == null) return;
    const parsed = Number(res);
    if (!Number.isFinite(parsed)) return;
    let next = parsed;
    if (min != null) next = Math.max(min, next);
    if (max != null) next = Math.min(max, next);
    onApply(next);
  };

  const handleAddVideoFromLibrary = (item: MediaLibraryItem) => {
    setSession((prev) => {
      const existing = prev.videoPaths ?? [];
      const existingIds = prev.videoIds ?? [];
      const nextNames = { ...(prev.videoNames ?? {}) };
      nextNames[item.path] = item.name;
      return { ...prev, videoPaths: [...existing, item.path], videoIds: [...existingIds, makeId()], videoNames: nextNames };
    });
    setStatus(`Added ${item.name} from library`);
    void updateProjectDirty(true);
  };

  const handleBrowseAndAddToLibrary = async () => {
    try {
      const paths = await openVideoFiles();
      console.info('[library] file picker returned', paths);
      if (!paths || paths.length === 0) return;
      let lastId: string | null = null;
      for (const p of paths) {
        const name = getClipName(p);
        const item = await addLibraryEntryFromPath(p, name);
        lastId = item.id;
      }
      if (lastId) {
        setLibrarySelectedId(lastId);
        setCollapsed((prev) => ({ ...prev, library: false }));
        console.info('[library] last added selected', lastId);
      } else {
        console.info('[library] no items added after picker');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
      console.error('[library] add flow failed', err);
    }
  };

  const validateLicenseKey = (key: string) => {
    const normalized = key.trim().toUpperCase();
    return /^[A-Z0-9]{4}(-[A-Z0-9]{4}){3}$/.test(normalized);
  };

  const ensureLicensed = useCallback(() => {
    if (isLicensed) return true;
    setLicenseModalOpen(true);
    setLicenseError(null);
    setStatus('Trial: upgrade to unlock project actions');
    return false;
  }, [isLicensed]);

  const handleValidateLicense = async () => {
    const trimmed = licenseKeyInput.trim();
    if (!validateLicenseKey(trimmed)) {
      setLicenseError('Invalid product key format. Use XXXX-XXXX-XXXX-XXXX.');
      return;
    }
    setLicenseStatus({ licensed: true, key: trimmed });
    setLicenseError(null);
    setLicenseModalOpen(false);
    setStatus('License activated');
  };

  const toggleSection = (key: keyof typeof collapsed) => {
    setCollapsed((prev) => ({ ...prev, [key]: !prev[key] }));
  };

  const getClipLabel = useCallback((path: string) => {
    const names = session.videoNames ?? {};
    if (names[path]) return names[path];
    const hit = library.find((i) => i.path === path);
    if (hit?.name) return hit.name;
    return path.split(/[\\/]/).pop() || path;
  }, [library, session.videoNames]);

  const clipNames = useMemo(() => {
    const map: Record<string, string> = {};
    (session.videoPaths ?? []).forEach((p) => { map[p] = getClipLabel(p); });
    return map;
  }, [session.videoPaths, getClipLabel]);
  const clipEdits = useMemo(() => session.clipEdits ?? {}, [session.clipEdits]);
  const clipSegments = useMemo(() => {
    const paths = session.videoPaths ?? [];
    const ids = session.videoIds ?? [];
    let cursor = 0;
    return paths.map((path, index) => {
      const id = ids[index] || `${index}:${path}`;
      const edit = clipEdits[id] ?? {};
      const sourceDuration = videoDurations[path] ?? 0;
      const trimStart = Math.max(0, Number(edit.trimStart ?? 0));
      const trimEnd = Number.isFinite(edit.trimEnd as number)
        ? Math.max(trimStart, Number(edit.trimEnd))
        : (sourceDuration > 0 ? sourceDuration : trimStart);
      const trimmedLength = Math.max(0.05, trimEnd - trimStart);
      const duration = Number.isFinite(edit.duration as number)
        ? Math.max(0.05, Number(edit.duration))
        : trimmedLength;
      const startOverride = Number.isFinite(edit.timelineStart as number)
        ? Math.max(0, Number(edit.timelineStart))
        : null;
      const start = startOverride === null ? cursor : Math.max(cursor, startOverride);
      const end = start + duration;
      cursor = Math.max(cursor, end);
      return {
        id,
        path,
        index,
        start,
        end,
        duration,
        trimStart,
        trimEnd,
        sourceDuration,
        hue: edit.hue,
        contrast: edit.contrast,
        brightness: edit.brightness,
        rotate: edit.rotate,
        flipH: edit.flipH,
        flipV: edit.flipV,
        invert: edit.invert,
        trimmedLength,
      };
    });
  }, [clipEdits, session.videoPaths, session.videoIds, videoDurations]);
  const timelineDuration = useMemo(() => {
    if (audioDuration > 0) return audioDuration;
    return clipSegments.reduce((acc, seg) => Math.max(acc, seg.end ?? 0), 0);
  }, [audioDuration, clipSegments]);
  const projectLocked = !isLicensed;

  const buildProjectFromSession = useCallback((): ProjectSchema => {
    const clips: ProjectSchema['clips'] = clipSegments.map((seg) => {
      const clip: ProjectSchema['clips'][number] = {
        path: seg.path,
        index: seg.index,
        label: (session.videoNames ?? {})[seg.path],
      };
      if (Number.isFinite(seg.start as number)) clip.start = seg.start;
      clip.trimStart = seg.trimStart;
      clip.trimEnd = seg.trimEnd;
      clip.duration = seg.duration;
      if (Number.isFinite(seg.hue as number)) clip.hue = seg.hue;
      if (Number.isFinite(seg.contrast as number)) clip.contrast = seg.contrast;
      if (Number.isFinite(seg.brightness as number)) clip.brightness = seg.brightness;
      if (Number.isFinite(seg.rotate as number)) clip.rotate = seg.rotate;
      if (typeof seg.flipH === 'boolean') clip.flipH = seg.flipH;
      if (typeof seg.flipV === 'boolean') clip.flipV = seg.flipV;
      if (typeof seg.invert === 'boolean') clip.invert = seg.invert;
      return clip;
    });
    const audio = session.audioPath ? { path: session.audioPath } : null;
    const playhead = typeof session.playhead === 'number' && Number.isFinite(session.playhead) ? session.playhead : 0;
    const metadata: Record<string, unknown> = {};
    if (session.theme) metadata.theme = session.theme;
    if (canvasPreset) {
      metadata.canvas = { preset: canvasPreset, width: canvasSize.width, height: canvasSize.height };
    }
    return {
      version: '1.0',
      audio,
      playhead,
      clips,
      layers: session.layers ?? [],
      metadata: Object.keys(metadata).length > 0 ? metadata : undefined,
    };
  }, [canvasPreset, canvasSize.height, canvasSize.width, clipSegments, session.audioPath, session.playhead, session.layers, session.videoNames]);

  useEffect(() => {
    if (!clipEditor) {
      setClipEditorDraft(null);
      return;
    }
    const seg = clipSegments.find((item) => item.id === clipEditor.id);
    if (!seg) return;
    setClipEditorDraft({
      timelineStart: seg.start,
      timelineEnd: seg.end,
      trimStart: seg.trimStart,
      trimEnd: seg.trimEnd,
      duration: seg.duration,
      hue: Number.isFinite(seg.hue as number) ? seg.hue : 0,
      contrast: Number.isFinite(seg.contrast as number) ? seg.contrast : 1,
      brightness: Number.isFinite(seg.brightness as number) ? seg.brightness : 1,
      rotate: Number.isFinite(seg.rotate as number) ? seg.rotate : 0,
      flipH: !!seg.flipH,
      flipV: !!seg.flipV,
      invert: !!seg.invert,
    });
  }, [clipEditor, clipSegments]);

  const openClipContextMenu = (id: string, path: string, index: number, x: number, y: number) => {
    setContextMenu({ id, path, index, x, y });
  };

  const closeContextMenu = () => setContextMenu(null);

  const reorderList = <T,>(arr: T[], from: number, to: number) => {
    const next = arr.slice();
    const [item] = next.splice(from, 1);
    next.splice(to, 0, item);
    return next;
  };

  const updateClipEdit = useCallback((id: string, patch: Partial<ClipEdit>) => {
    setSession((prev) => {
      const edits = { ...(prev.clipEdits ?? {}) };
      const existing = edits[id] ?? {};
      edits[id] = { ...existing, ...patch };
      return { ...prev, clipEdits: edits };
    });
    void updateProjectDirty(true);
  }, []);

  const applyTrimEdit = useCallback((id: string, trimStart: number, duration: number) => {
    const seg = clipSegments.find((item) => item.id === id);
    const maxEnd = seg?.trimEnd ?? (seg?.sourceDuration ?? Number.POSITIVE_INFINITY);
    const nextStart = Math.max(0, trimStart);
    const clampedStart = Math.max(0, Math.min(maxEnd - 0.05, nextStart));
    const nextDuration = Math.max(0.05, duration);
    updateClipEdit(id, { trimStart: clampedStart, duration: nextDuration });
  }, [clipSegments, updateClipEdit]);

  const applyDurationEdit = useCallback((id: string, duration: number) => {
    const nextDuration = Math.max(0.05, duration);
    updateClipEdit(id, { duration: nextDuration });
  }, [updateClipEdit]);

  const handlePickImageForLayer = useCallback(async () => {
    try {
      const path = await openImageFile();
      if (path) {
        updateLayerDraftField({ imagePath: path });
      }
    } catch (err) {
      console.warn('Failed to pick image', err);
    }
  }, [updateLayerDraftField]);

  const handleReorderClips = useCallback((from: number, to: number) => {
    setSession((prev) => {
      const paths = prev.videoPaths ?? [];
      const ids = prev.videoIds ?? [];
      if (from === to || from < 0 || to < 0 || from >= paths.length || to >= paths.length) return prev;
      const nextPaths = reorderList(paths, from, to);
      const nextIds = ids.length === paths.length ? reorderList(ids, from, to) : ids;
      return { ...prev, videoPaths: nextPaths, videoIds: nextIds };
    });
    void updateProjectDirty(true);
  }, []);


  const removeClipAt = (idx: number) => {
    setSession((prev) => {
      const next = (prev.videoPaths ?? []).slice();
      const ids = (prev.videoIds ?? []).slice();
      const removedId = ids[idx];
      next.splice(idx, 1);
      if (ids.length) ids.splice(idx, 1);
      const edits = { ...(prev.clipEdits ?? {}) };
      if (removedId) delete edits[removedId];
      return { ...prev, videoPaths: next, videoIds: ids, clipEdits: edits };
    });
    setContextMenu(null);
    void updateProjectDirty(true);
  };

  const duplicateClipAt = (idx: number) => {
    setSession((prev) => {
      const paths = prev.videoPaths ?? [];
      const ids = prev.videoIds ?? [];
      if (idx < 0 || idx >= paths.length) return prev;
      const dup = paths[idx];
      const next = paths.slice();
      next.splice(idx + 1, 0, dup);
      const nextIds = ids.slice();
      const newId = makeId();
      nextIds.splice(idx + 1, 0, newId);
      const edits = { ...(prev.clipEdits ?? {}) };
      const sourceId = ids[idx];
      if (sourceId && edits[sourceId]) {
        edits[newId] = { ...edits[sourceId] };
      }
      return { ...prev, videoPaths: next, videoIds: nextIds, clipEdits: edits };
    });
    setContextMenu(null);
    void updateProjectDirty(true);
  };

  const startRenameClip = (path: string, index: number) => {
    setRenameTarget({ path, index, name: getClipLabel(path) });
    setContextMenu(null);
  };

  const applyRenameClip = async () => {
    if (!renameTarget) return;
    const { path, name } = renameTarget;
    const trimmed = name.trim();
    const nextName = trimmed || getClipLabel(path);
    const hit = library.find((i) => i.path === path);
    if (hit) {
      await updateLibraryName(path, nextName);
    } else {
      setSession((prev) => ({ ...prev, videoNames: { ...(prev.videoNames ?? {}), [path]: nextName } }));
    }
    setStatus(`Renamed clip to ${nextName}`);
    setRenameTarget(null);
    void updateProjectDirty(true);
  };

  const handleClipInfo = (path: string) => {
    const label = getClipLabel(path);
    const dur = videoDurations[path];
    setStatus(`Clip: ${label} (${dur ? `${dur.toFixed(1)}s` : 'n/a'})`);
    setContextMenu(null);
  };

  const handleClipEdit = (id: string, path: string, index: number) => {
    setClipEditor({ id, path, index });
    setContextMenu(null);
  };

  const closeClipEditor = () => {
    setClipEditor(null);
    setClipEditorDraft(null);
  };

  const applyClipEditor = () => {
    if (!clipEditor || !clipEditorDraft) return;
    const seg = clipSegments.find((item) => item.id === clipEditor.id);
    if (!seg) return;
    const timelineStart = Math.max(0, Number(clipEditorDraft.timelineStart ?? seg.start ?? 0));
    const timelineEnd = Number.isFinite(clipEditorDraft.timelineEnd as number)
      ? Number(clipEditorDraft.timelineEnd)
      : (timelineStart + seg.duration);
    const duration = Math.max(0.05, timelineEnd - timelineStart);
    const trimStart = Math.max(0, Number(clipEditorDraft.trimStart ?? seg.trimStart ?? 0));
    const sourceDuration = seg.sourceDuration || 0;
    let trimEnd = Number.isFinite(clipEditorDraft.trimEnd as number)
      ? Number(clipEditorDraft.trimEnd)
      : (sourceDuration > 0 ? sourceDuration : trimStart + duration);
    if (sourceDuration > 0) trimEnd = Math.min(trimEnd, sourceDuration);
    trimEnd = Math.max(trimStart + 0.05, trimEnd);
    updateClipEdit(clipEditor.id, {
      timelineStart,
      duration,
      trimStart,
      trimEnd,
      hue: Number(clipEditorDraft.hue ?? 0),
      contrast: Number(clipEditorDraft.contrast ?? 1),
      brightness: Number(clipEditorDraft.brightness ?? 1),
      rotate: Number(clipEditorDraft.rotate ?? 0),
      flipH: !!clipEditorDraft.flipH,
      flipV: !!clipEditorDraft.flipV,
      invert: !!clipEditorDraft.invert,
    });
    closeClipEditor();
  };

  const updateClipEditorDraft = useCallback((patch: Partial<ClipEdit> & { timelineStart?: number; timelineEnd?: number }) => {
    setClipEditorDraft((prev) => (prev ? { ...prev, ...patch } : prev));
  }, []);

  const handleClipAddToLibrary = async (path: string) => {
    const exists = library.some((item) => item.path === path);
    if (exists) {
      setContextMenu(null);
      return;
    }
    const name = getClipLabel(path);
    await addLibraryEntryFromPath(path, name);
    setContextMenu(null);
  };

  const handleLoadProject = async () => {
    if (!ensureLicensed()) return;
    try {
      const opened = await openProject();
      if (opened) {
        const project = opened.project as any;
        const clipList = Array.isArray(project?.clips) ? project.clips.filter((c: any) => c?.path) : [];
        const nextVideos = clipList.map((c: any) => c?.path).filter(Boolean);
        const nextIds = nextVideos.map(() => makeId());
        const nextNames: Record<string, string> = {};
        const nextEdits: Record<string, ClipEdit> = {};
        clipList.forEach((c: any, idx: number) => {
          if (c?.path && c.label) nextNames[c.path] = c.label;
          const edit: ClipEdit = {};
          if (Number.isFinite(c?.trimStart)) edit.trimStart = Number(c.trimStart);
          if (Number.isFinite(c?.trimEnd)) edit.trimEnd = Number(c.trimEnd);
          if (Number.isFinite(c?.duration)) edit.duration = Number(c.duration);
          if (Number.isFinite(c?.start)) edit.timelineStart = Number(c.start);
          if (Number.isFinite(c?.hue)) edit.hue = Number(c.hue);
          if (Number.isFinite(c?.contrast)) edit.contrast = Number(c.contrast);
          if (Number.isFinite(c?.brightness)) edit.brightness = Number(c.brightness);
          if (Number.isFinite(c?.rotate)) edit.rotate = Number(c.rotate);
          if (typeof c?.flipH === 'boolean') edit.flipH = c.flipH;
          if (typeof c?.flipV === 'boolean') edit.flipV = c.flipV;
          if (typeof c?.invert === 'boolean') edit.invert = c.invert;
          if (Object.keys(edit).length > 0) {
            nextEdits[nextIds[idx]] = edit;
          }
        });
        setSession((prev) => ({
          ...prev,
          projectSavePath: opened.path,
          audioPath: project?.audio?.path ?? undefined,
          videoPaths: nextVideos,
          videoIds: nextIds,
          clipEdits: nextEdits,
          videoNames: nextNames,
          playhead: typeof project?.playhead === 'number' ? project.playhead : 0,
          layers: Array.isArray(project?.layers) ? project.layers : [],
        }));
        setStatus('Project loaded');
        await updateProjectDirty(false);
      }
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleSaveProject = async () => {
    if (!ensureLicensed()) return;
    try {
      const project = buildProjectFromSession();
      let target = session.projectSavePath;
      if (!target) {
        const defaultPath = await getDefaultProjectPath();
        target = await chooseProjectSavePath(defaultPath);
        if (!target) return;
        setSession((prev) => ({ ...prev, projectSavePath: target }));
      }
      await saveProject(target, project);
      await updateProjectDirty(false);
      notifyProjectSaved(true);
      setStatus('Project saved');
    } catch (e: unknown) {
      notifyProjectSaved(false);
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleSaveProjectAs = async () => {
    if (!ensureLicensed()) return;
    try {
      const defaultPath = session.projectSavePath ?? await getDefaultProjectPath();
      const target = await chooseProjectSavePath(defaultPath);
      if (!target) return;
      setSession((prev) => ({ ...prev, projectSavePath: target }));
      const project = buildProjectFromSession();
      await saveProject(target, project);
      await updateProjectDirty(false);
      notifyProjectSaved(true);
      setStatus('Project saved as...');
    } catch (e: unknown) {
      notifyProjectSaved(false);
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleStartRender = async () => {
    if (!ensureLicensed()) return;
    try {
      const project = buildProjectFromSession();
      let target = session.projectSavePath;
      if (!target) {
        const defaultPath = await getDefaultProjectPath();
        target = await chooseProjectSavePath(defaultPath);
        if (!target) {
          setStatus('Render cancelled: no project path selected');
          return;
        }
        setSession((prev) => ({ ...prev, projectSavePath: target }));
      }
      await saveProject(target, project);
      await updateProjectDirty(false);

      const outputPath = await chooseRenderOutput(target);
      if (!outputPath) {
        setStatus('Render cancelled');
        return;
      }
      const preparedPath = await prepareRenderProject(target, outputPath);

      setIsRendering(true);
      setRenderElapsedMs(0);
      setRenderTotalMs(0);
      setLogs([]);
      setStatus('Render started');
      void startRender(preparedPath).catch((err) => {
        setIsRendering(false);
        setError(err instanceof Error ? err.message : String(err));
      });
    } catch (e: unknown) {
      setIsRendering(false);
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleNotesChange = (ev: ChangeEvent<HTMLTextAreaElement>) => {
    const value = ev.target.value;
    setSession((prev) => ({ ...prev, notes: value }));
    void updateProjectDirty(true);
  };

  const handleSave = async () => {
    try {
      const { audioPath, videoPaths, projectSavePath, playhead, ...rest } = session;
      const toSave: SessionState = { ...(rest as SessionState) };
      await saveSessionState(toSave);
      setStatus('Session saved');
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  const handleExport = async () => {
    try {
      const targetPath = session.projectSavePath;
      if (!targetPath) {
        setError('Set a project path before export');
        return;
      }
      await exportSession({ targetPath, state: (session as unknown as SessionState) });
      setStatus('Session exported');
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : String(e));
    }
  };

  // Load video durations to scale storyboard items
  useEffect(() => {
    const paths = session.videoPaths ?? [];
    if (paths.length === 0) { setVideoDurations({}); return; }
    let cancel = false;
    const next: Record<string, number> = {};
    let loaded = 0;
    paths.forEach((p) => {
      const v = document.createElement('video');
      v.preload = 'metadata';
      v.src = toFileURL(p);
      const done = () => {
        loaded += 1;
        if (!cancel) {
          if (Number.isFinite(v.duration)) next[p] = v.duration;
          if (loaded === paths.length) setVideoDurations(next);
        }
        v.src = '';
      };
      v.addEventListener('loadedmetadata', done, { once: true });
      v.addEventListener('error', done, { once: true });
      // In case metadata is cached
      if (Number.isFinite(v.duration) && v.duration > 0) done();
    });
    return () => { cancel = true; };
  }, [session.videoPaths]);

  useEffect(() => {
    const audioPath = session.audioPath;
    if (!audioPath) {
      setOverviewPeaks([]);
      return;
    }
    // Show something immediately while decoding
    setOverviewPeaks(makePseudoPeaks(audioPath));
    let cancelled = false;

    const generatePeaks = async () => {
      try {
        const buf = await readFileBuffer(audioPath);
        const slice = buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength
          ? buf.buffer
          : buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        // Ensure we hand AudioContext a real ArrayBuffer (not SharedArrayBuffer)
        const arrayBuffer = slice instanceof ArrayBuffer
          ? slice
          : (() => {
              const copy = new Uint8Array(slice.byteLength);
              copy.set(new Uint8Array(slice));
              return copy.buffer;
            })();
        const AudioCtor = window.AudioContext || (window as WebAudioWindow).webkitAudioContext;
        if (!AudioCtor) throw new Error('AudioContext unavailable');
        const audioCtx = new AudioCtor();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        if (cancelled) {
          await audioCtx.close();
          return;
        }
        const channelData = decoded.numberOfChannels > 0 ? decoded.getChannelData(0) : undefined;
        if (!channelData) {
          await audioCtx.close();
          throw new Error('No channel data');
        }
        const bucketCount = 640;
        const samplesPerBucket = Math.max(1, Math.floor(channelData.length / bucketCount));
        const peaks: number[] = [];
        for (let bucket = 0; bucket < bucketCount; bucket++) {
          const start = bucket * samplesPerBucket;
          if (start >= channelData.length) break;
          let peak = 0;
          for (let i = 0; i < samplesPerBucket && start + i < channelData.length; i++) {
            const sample = Math.abs(channelData[start + i]);
            if (sample > peak) peak = sample;
          }
          peaks.push(peak);
        }
        await audioCtx.close();
        if (!cancelled) setOverviewPeaks(peaks);
      } catch (err) {
        if (!cancelled) {
          console.warn('Overview waveform generation failed:', err);
          setOverviewPeaks(makePseudoPeaks(audioPath));
        }
      }
    };

    void generatePeaks();
    return () => {
      cancelled = true;
    };
  }, [session.audioPath, makePseudoPeaks]);

  // Wire AudioMotion analyzer when audio element is available (lazy-loaded from CDN)
  useEffect(() => {
    if (!USE_AUDIO_MOTION) return;
    const audio = audioEl;
    if (!audio) return;
    let container: HTMLDivElement | null = null;
    let destroyed = false;
    (async () => {
      try {
        // @ts-ignore external ESM import
        const mod: any = await import(/* @vite-ignore */ 'https://cdn.jsdelivr.net/npm/audiomotion-analyzer@4.0.0/+esm');
        const AudioMotion = mod?.default ?? mod;
        if (!AudioMotion) return;
        if (destroyed) return;
        container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.left = '-9999px';
        container.style.top = '-9999px';
        container.style.width = '400px';
        container.style.height = '200px';
        document.body.appendChild(container);
        const am = new AudioMotion(container, {
          source: audio,
          height: 200,
          width: 400,
          mode: 10,
          ledBars: false,
          ansiBands: false,
          smoothing: 0.7,
          gradient: 'classic',
          showScale: false,
          overlay: true,
          bgAlpha: 0,
          showPeaks: false,
        });
        audioMotionRef.current = am;
      } catch (err) {
        console.warn('AudioMotion init failed', err);
      }
    })();
    return () => {
      destroyed = true;
      if (audioMotionRef.current) {
        try { (audioMotionRef.current as any).destroy?.(); } catch {}
        audioMotionRef.current = null;
      }
      if (container) {
        container.remove();
      }
    };
  }, [USE_AUDIO_MOTION, audioEl, session.audioPath]);

  useEffect(() => {
    const audio = audioEl;
    if (!audio) return undefined;
    let ctx: AudioContext | null = null;
    let source: MediaElementAudioSourceNode | null = null;
    let analyser: AnalyserNode | null = null;
    let gain: GainNode | null = null;
    const cleanup = () => {
      try { source?.disconnect(); } catch {}
      try { analyser?.disconnect(); } catch {}
      try { gain?.disconnect(); } catch {}
      if (ctx) {
        try { ctx.close(); } catch {}
      }
      spectroAudioCtxRef.current = null;
      spectroSourceRef.current = null;
      spectroAnalyserRef.current = null;
      spectroGainRef.current = null;
    };
    try {
      const AudioCtor = window.AudioContext || (window as WebAudioWindow).webkitAudioContext;
      if (!AudioCtor) return cleanup;
      ctx = new AudioCtor();
      source = ctx.createMediaElementSource(audio);
      analyser = ctx.createAnalyser();
      gain = ctx.createGain();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.7;
      source.connect(analyser);
      analyser.connect(gain);
      gain.connect(ctx.destination);
      spectroAudioCtxRef.current = ctx;
      spectroSourceRef.current = source;
      spectroAnalyserRef.current = analyser;
      spectroGainRef.current = gain;
      const onPlay = () => { void ctx?.resume(); };
      audio.addEventListener('play', onPlay);
      return () => {
        audio.removeEventListener('play', onPlay);
        cleanup();
      };
    } catch {
      cleanup();
      return undefined;
    }
  }, [audioEl]);

  useEffect(() => {
    const gain = spectroGainRef.current;
    if (!gain) return;
    gain.gain.value = Math.min(1, Math.max(0, volume));
  }, [volume]);

  const resolveActiveClip = useCallback((playheadSec: number) => {
    for (const seg of clipSegments) {
      const start = seg.start ?? 0;
      const end = seg.end ?? (start + seg.duration);
      if (playheadSec >= start && playheadSec <= end) {
        const rel = Math.max(0, playheadSec - start);
        const loopLen = Math.max(0.05, seg.trimmedLength || (seg.sourceDuration || 0));
        const local = seg.trimStart + (loopLen > 0 ? (rel % loopLen) : 0);
        return { path: seg.path, local, duration: seg.duration };
      }
    }
    return null;
  }, [clipSegments]);

  const renderPreviewFrame = useCallback(async () => {
    if (previewBusyRef.current) {
      previewQueuedRef.current = true;
      return;
    }
    const canvas = previewCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    previewBusyRef.current = true;
    const dpr = window.devicePixelRatio || 1;
    const logicalW = canvas.clientWidth || 800;
    const logicalH = canvas.clientHeight || 450;
    const stageAspect = canvasSize.width / canvasSize.height;
    const stageW = (logicalW / logicalH) > stageAspect ? (logicalH * stageAspect) : logicalW;
    const stageH = stageW / stageAspect;
    const stageX = (logicalW - stageW) / 2;
    const stageY = (logicalH - stageH) / 2;
    const stageScale = stageW / canvasSize.width;
    canvas.width = Math.floor(logicalW * dpr);
    canvas.height = Math.floor(logicalH * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, logicalW, logicalH);
    ctx.fillStyle = '#0b0f16';
    ctx.fillRect(0, 0, logicalW, logicalH);

    ctx.save();
    ctx.beginPath();
    ctx.rect(stageX, stageY, stageW, stageH);
    ctx.clip();

    const active = resolveActiveClip(session.playhead ?? 0);
    if (active) {
      const vid = videoPoolRef.current.get(active.path);
      if (vid) {
        const targetTime = Math.min(Math.max(0, active.local), (vid.duration || active.duration || 0));
        let seekOk = false;
        if (vid.readyState >= 2 && Math.abs((vid.currentTime || 0) - targetTime) < 0.01) {
          seekOk = true;
        } else {
          seekOk = await new Promise<boolean>((resolve) => {
            const handler = () => resolve(true);
            vid.currentTime = targetTime;
            vid.addEventListener('seeked', handler, { once: true });
            setTimeout(() => resolve(false), 500);
          });
        }
        if (seekOk) {
          try {
            const vw = vid.videoWidth || logicalW;
            const vh = vid.videoHeight || logicalH;
            const scale = Math.min(stageW / vw, stageH / vh);
            const dw = vw * scale;
            const dh = vh * scale;
            const dx = stageX + (stageW - dw) / 2;
            const dy = stageY + (stageH - dh) / 2;
            ctx.drawImage(vid, dx, dy, dw, dh);
          } catch {
            // ignore draw errors
          }
        }
      }
    }

    const analyser = spectroAnalyserRef.current;
    let audioData: Uint8Array | null = null;
    let audioAmplitude = 0;
    if (analyser) {
      audioData = new Uint8Array(new ArrayBuffer(analyser.frequencyBinCount));
      const live = !!audioEl && !audioEl.paused;
      if (live) {
        analyser.getByteFrequencyData(audioData as Uint8Array<ArrayBuffer>);
        spectroLastDataRef.current = audioData.slice();
      } else if (spectroLastDataRef.current && spectroLastDataRef.current.length === audioData.length) {
        audioData.set(spectroLastDataRef.current);
      } else {
        analyser.getByteFrequencyData(audioData as Uint8Array<ArrayBuffer>);
      }
      let sum = 0;
      for (let i = 0; i < audioData.length; i++) sum += audioData[i];
      audioAmplitude = sum / (audioData.length * 255);
    }
    const nowMs = performance.now();

    // Draw layers
    for (const layer of layers) {
      const x = stageX + (layer.x ?? 0) * stageW;
      const y = stageY + (layer.y ?? 0) * stageH;
      const baseW = layer.width ?? canvasSize.width;
      const baseH = layer.height ?? Math.round(baseW * (canvasSize.height / canvasSize.width));
      const drawW = Math.max(10, baseW * stageScale);
      const drawH = Math.max(10, baseH * stageScale);
      const opacity = Math.min(1, Math.max(0, layer.opacity ?? 1));
      const rotateDeg = layer.rotate ?? 0;
      const rotateRad = (rotateDeg * Math.PI) / 180;
      const reverse = !!layer.reverse;
      if (layer.type === 'spectrograph') {
        if (analyser && audioData) {
          const workCanvas = spectroWorkRef.current ?? document.createElement('canvas');
          if (!spectroWorkRef.current) spectroWorkRef.current = workCanvas;
          const barCanvasW = 512;
          const barCanvasH = 200;
          workCanvas.width = barCanvasW;
          workCanvas.height = barCanvasH;
          const workCtx = workCanvas.getContext('2d');
          if (!workCtx) continue;
          workCtx.clearRect(0, 0, barCanvasW, barCanvasH);
          const data = audioData;
          const mode = layer.mode ?? 'bar';
          const pathMode = layer.pathMode ?? 'straight';
          const freqScale = layer.freqScale ?? 'log';
          const ampScale = layer.ampScale ?? 'log';
          const barCount = mode === 'dots'
            ? (layer.dotCount ?? 96)
            : mode === 'solid'
              ? (layer.solidPointCount ?? 96)
              : (layer.barCount ?? 96);
          const step = Math.max(1, Math.floor(data.length / barCount));
          const barW = barCanvasW / barCount;
          const barWidthPct = mode === 'bar' || mode === 'solid' ? (layer.barWidthPct ?? 0.8) : 0.6;
          const averaging = Math.max(1, Math.round(layer.averaging ?? 1));
          const scaleAmp = (v: number) => {
            if (ampScale === 'lin') return v;
            if (ampScale === 'sqrt') return Math.sqrt(v);
            if (ampScale === 'cbrt') return Math.cbrt(v);
            return Math.log10(1 + 9 * v);
          };
          const scaleIndex = (i: number) => {
            if (freqScale === 'lin') return i;
            const t = i / Math.max(1, barCount - 1);
            if (freqScale === 'rlog') {
              return Math.floor((1 - Math.pow(1 - t, 2)) * (barCount - 1));
            }
            return Math.floor(Math.pow(t, 2) * (barCount - 1));
          };
          const sampleValue = (i: number) => {
            const sIdx = scaleIndex(i);
            if (averaging <= 1) {
              return data[sIdx * step] / 255;
            }
            const half = Math.floor(averaging / 2);
            let sum = 0;
            let count = 0;
            for (let o = -half; o <= half; o++) {
              const idx = Math.min(barCount - 1, Math.max(0, sIdx + o));
              sum += data[idx * step] / 255;
              count += 1;
            }
            return sum / Math.max(1, count);
          };
          const fill = layer.color ?? '';
          let gradient: CanvasGradient | null = null;
          if (!fill) {
            gradient = workCtx.createLinearGradient(0, 0, 0, barCanvasH);
            gradient.addColorStop(0, '#ff3b3b');
            gradient.addColorStop(0.55, '#ffd400');
            gradient.addColorStop(1, '#00ff7a');
          }
          workCtx.fillStyle = fill || gradient || '#00ff7a';
          if (mode === 'line') {
            workCtx.beginPath();
            for (let i = 0; i < barCount; i++) {
              const v = sampleValue(i);
              const h = Math.max(1, Math.floor(scaleAmp(v) * barCanvasH));
              const xPos = i * barW + barW / 2;
              const yPos = layer.invert ? h : (barCanvasH - h);
              if (i === 0) workCtx.moveTo(xPos, yPos);
              else workCtx.lineTo(xPos, yPos);
            }
            workCtx.strokeStyle = fill || gradient || '#00ff7a';
            workCtx.lineWidth = Math.max(1, barW * 0.4);
            workCtx.stroke();
          } else if (mode === 'dots') {
            const radius = Math.max(1, (barW * barWidthPct) / 2);
            for (let i = 0; i < barCount; i++) {
              const v = sampleValue(i);
              const h = Math.max(1, Math.floor(scaleAmp(v) * barCanvasH));
              const xPos = i * barW + barW / 2;
              const yPos = layer.invert ? h : (barCanvasH - h);
              workCtx.beginPath();
              workCtx.arc(xPos, yPos, radius, 0, Math.PI * 2);
              workCtx.fill();
            }
          } else {
            const widthScale = mode === 'solid' ? 1 : barWidthPct;
            for (let i = 0; i < barCount; i++) {
              const v = sampleValue(i);
              const h = Math.max(1, Math.floor(scaleAmp(v) * barCanvasH));
              const xPos = i * barW;
              const barWidth = Math.max(1, barW * widthScale);
              const yPos = layer.invert ? 0 : (barCanvasH - h);
              workCtx.fillRect(xPos, yPos, barWidth, h);
            }
          }
          const finalCanvas = workCanvas;
          const glowAmount = layer.glowAmount ?? 0;
          const glowOpacity = layer.glowOpacity ?? 0.4;
          const glowColor = layer.glowColor ?? layer.color ?? '#ffffff';
          const outlineWidth = layer.outlineWidth ?? 0;
          const outlineColor = layer.outlineColor ?? '#000000';
          const shadowDistance = layer.shadowDistance ?? 0;
          const shadowColor = layer.shadowColor ?? '#000000';
          ctx.save();
          ctx.translate(x + drawW / 2, y + drawH / 2);
          ctx.rotate(rotateRad);
          if (reverse) ctx.scale(-1, 1);
          ctx.globalAlpha = opacity;
          if (pathMode === 'circular') {
            const drawCircular = (flipX: boolean, flipY: boolean) => {
              ctx.save();
              ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
              const radius = Math.min(drawW, drawH) / 2;
              const innerRadius = radius * 0.1;
              const angleStep = (Math.PI * 2) / barCount;
              if (shadowDistance > 0) {
                ctx.save();
                ctx.shadowOffsetX = shadowDistance;
                ctx.shadowOffsetY = shadowDistance;
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = 0;
                ctx.restore();
              }
              if (glowAmount > 0) {
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = glowAmount;
                ctx.globalAlpha = glowOpacity;
              }
              ctx.fillStyle = fill || gradient || '#00ff7a';
              ctx.strokeStyle = fill || gradient || '#00ff7a';
              for (let i = 0; i < barCount; i++) {
                const v = sampleValue(i);
                const mag = Math.max(1, scaleAmp(v) * (radius - innerRadius));
                const startAngle = -Math.PI / 2 + i * angleStep;
                const thickness = angleStep * (mode === 'bar' || mode === 'solid' ? barWidthPct : 0.6);
                const angle = startAngle + thickness / 2;
                const outer = layer.invert ? innerRadius : innerRadius + mag;
                const inner = layer.invert ? innerRadius + mag : innerRadius;
                if (mode === 'dots') {
                  const dotR = Math.max(2, radius * 0.015 * barWidthPct);
                  const rx = Math.cos(angle) * outer;
                  const ry = Math.sin(angle) * outer;
                  ctx.beginPath();
                  ctx.arc(rx, ry, dotR, 0, Math.PI * 2);
                  ctx.fill();
                } else if (mode === 'line') {
                  ctx.lineWidth = Math.max(1, radius * 0.01 * barWidthPct);
                  ctx.beginPath();
                  ctx.moveTo(Math.cos(angle) * inner, Math.sin(angle) * inner);
                  ctx.lineTo(Math.cos(angle) * outer, Math.sin(angle) * outer);
                  ctx.stroke();
                } else {
                  const start = startAngle;
                  const end = startAngle + thickness;
                  ctx.beginPath();
                  ctx.arc(0, 0, outer, start, end, false);
                  ctx.arc(0, 0, inner, end, start, true);
                  ctx.closePath();
                  ctx.fill();
                }
              }
              ctx.restore();
            };
            drawCircular(false, false);
            if (layer.mirrorX) drawCircular(true, false);
            if (layer.mirrorY) drawCircular(false, true);
            if (layer.mirrorX && layer.mirrorY) drawCircular(true, true);
          } else {
            if (shadowDistance > 0) {
              ctx.save();
              ctx.shadowOffsetX = shadowDistance;
              ctx.shadowOffsetY = shadowDistance;
              ctx.shadowColor = shadowColor;
              ctx.shadowBlur = 0;
              ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
              ctx.restore();
            }
            if (outlineWidth > 0) {
              ctx.save();
              ctx.shadowColor = outlineColor;
              ctx.shadowBlur = outlineWidth;
              ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
              ctx.restore();
            }
            if (glowAmount > 0) {
              ctx.save();
              ctx.shadowColor = glowColor;
              ctx.shadowBlur = glowAmount;
              ctx.globalAlpha = glowOpacity;
              ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
              ctx.restore();
            }
            ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
            if (layer.mirrorX || layer.mirrorY) {
              ctx.save();
              ctx.scale(layer.mirrorX ? -1 : 1, layer.mirrorY ? -1 : 1);
              ctx.drawImage(finalCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
              ctx.restore();
            }
          }
          ctx.restore();
        } else {
          const am = audioMotionRef.current;
          if (am?.canvas) {
            try { am.draw?.(); } catch {}
            const srcCanvas = am.canvas as HTMLCanvasElement;
            const sourceW = srcCanvas.width;
            const sourceH = Math.floor(srcCanvas.height * 0.8);
            const cacheCanvas = spectroCacheRef.current ?? document.createElement('canvas');
            if (!spectroCacheRef.current) spectroCacheRef.current = cacheCanvas;
            cacheCanvas.width = sourceW;
            cacheCanvas.height = sourceH;
            const cacheCtx = cacheCanvas.getContext('2d');
            if (cacheCtx) {
              cacheCtx.clearRect(0, 0, sourceW, sourceH);
              cacheCtx.drawImage(srcCanvas, 0, 0, sourceW, sourceH, 0, 0, sourceW, sourceH);
            }
            ctx.save();
            ctx.translate(x + drawW / 2, y + drawH / 2);
            ctx.rotate(rotateRad);
            if (reverse) ctx.scale(-1, 1);
            ctx.globalAlpha = opacity;
            ctx.drawImage(cacheCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
            ctx.restore();
          } else {
            // Fallback visual if analyser not ready
            ctx.save();
            ctx.fillStyle = layer.color ?? '#7ea5ff';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(x, y, drawW, drawH);
            ctx.restore();
          }
        }
      } else if (layer.type === 'image') {
        const imgPath = (layer as any).imagePath;
        if (!imgPath) continue;
        const img = imagePoolRef.current.get(imgPath);
        if (!img || !img.complete) continue;
        const outlineWidth = layer.outlineWidth ?? 0;
        const outlineColor = layer.outlineColor ?? '#000000';
        const glowAmount = layer.glowAmount ?? 0;
        const glowColor = layer.glowColor ?? '#000000';
        const shadowDistance = layer.shadowDistance ?? 0;
        const shadowColor = layer.shadowColor ?? '#000000';
        ctx.save();
        ctx.translate(x + drawW / 2, y + drawH / 2);
        if (rotateRad) ctx.rotate(rotateRad);
        if (reverse) ctx.scale(-1, 1);
        ctx.globalAlpha = opacity;
        if (layer.invert) ctx.filter = 'invert(1)';
        if (shadowDistance > 0) {
          ctx.shadowColor = shadowColor;
          ctx.shadowBlur = Math.max(0, shadowDistance);
          ctx.shadowOffsetX = shadowDistance;
          ctx.shadowOffsetY = shadowDistance;
        }
        if (glowAmount > 0) {
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = glowAmount * 2;
        }
        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        if (outlineWidth > 0) {
          ctx.shadowColor = 'transparent';
          ctx.filter = 'none';
          ctx.lineWidth = outlineWidth;
          ctx.strokeStyle = outlineColor;
          ctx.strokeRect(-drawW / 2, -drawH / 2, drawW, drawH);
        }
        ctx.restore();
      } else if (layer.type === 'particles') {
        const count = Math.max(10, Math.round(layer.particleCount ?? 200));
        const direction = (layer.direction ?? 0) * (Math.PI / 180);
        const baseSpeed = Math.max(1, layer.speed ?? 60);
        const sizeMin = Math.max(1, layer.sizeMin ?? 2);
        const sizeMax = Math.max(sizeMin, layer.sizeMax ?? 6);
        const opacityMin = Math.max(0, Math.min(1, layer.opacityMin ?? 0.3));
        const opacityMax = Math.max(opacityMin, Math.min(1, layer.opacityMax ?? 0.9));
        const speedScale = layer.audioResponsive ? (1 + audioAmplitude) : 1;
        const isActive = !!audioEl && !audioEl.paused;
        const state = particleStateRef.current.get(layer.id) ?? {
          particles: [],
          lastTime: nowMs,
          width: drawW,
          height: drawH,
        };
        if (state.width !== drawW || state.height !== drawH) {
          const prevW = state.width || drawW;
          const prevH = state.height || drawH;
          for (const p of state.particles) {
            p.x = (p.x / prevW) * drawW;
            p.y = (p.y / prevH) * drawH;
          }
          state.width = drawW;
          state.height = drawH;
        }
        if (state.particles.length !== count) {
          if (state.particles.length > count) {
            state.particles.length = count;
          } else {
            const missing = count - state.particles.length;
            for (let i = 0; i < missing; i++) {
              state.particles.push({
                x: Math.random() * drawW,
                y: Math.random() * drawH,
                size: sizeMin + Math.random() * (sizeMax - sizeMin),
                opacity: opacityMin + Math.random() * (opacityMax - opacityMin),
                angleOffset: (Math.random() - 0.5) * (Math.PI / 6),
                speedScale: 0.7 + Math.random() * 0.6,
              });
            }
          }
        }
        const dt = isActive ? Math.min(0.05, (nowMs - state.lastTime) / 1000) : 0;
        state.lastTime = nowMs;
        particleStateRef.current.set(layer.id, state);
        ctx.save();
        ctx.translate(x + drawW / 2, y + drawH / 2);
        ctx.rotate(rotateRad);
        if (reverse) ctx.scale(-1, 1);
        ctx.globalAlpha = opacity;
        ctx.fillStyle = layer.color ?? '#7ea5ff';
        const originX = -drawW / 2;
        const originY = -drawH / 2;
        for (const p of state.particles) {
          if (dt > 0) {
            const speed = baseSpeed * p.speedScale * speedScale;
            p.x += Math.cos(direction + p.angleOffset) * speed * dt;
            p.y += Math.sin(direction + p.angleOffset) * speed * dt;
            if (p.x < 0) p.x += drawW;
            if (p.x > drawW) p.x -= drawW;
            if (p.y < 0) p.y += drawH;
            if (p.y > drawH) p.y -= drawH;
          }
          ctx.globalAlpha = opacity * p.opacity;
          ctx.beginPath();
          ctx.arc(originX + p.x, originY + p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      } else if (layer.type === 'text') {
        ctx.save();
        ctx.translate(x + drawW / 2, y + drawH / 2);
        ctx.rotate(rotateRad);
        if (reverse) ctx.scale(-1, 1);
        ctx.globalAlpha = opacity;
        const fontSize = Math.max(8, layer.fontSize ?? 12);
        ctx.font = `${fontSize}px ${layer.font ?? 'Segoe UI'}, sans-serif`;
        ctx.fillStyle = layer.color ?? '#ffffff';
        const shadowOpacity = layer.glowOpacity ?? 0.4;
        if (layer.glowAmount) {
          ctx.shadowColor = `${layer.glowColor ?? layer.color ?? '#ffffff'}${Math.round(shadowOpacity * 255).toString(16).padStart(2, '0')}`;
          ctx.shadowBlur = layer.glowAmount ?? 0;
        } else {
          ctx.shadowBlur = 0;
        }
        if (layer.shadowDistance) {
          ctx.shadowOffsetX = layer.shadowDistance;
          ctx.shadowOffsetY = layer.shadowDistance;
          ctx.shadowColor = layer.shadowColor ?? '#000000';
        }
        ctx.strokeStyle = layer.outlineColor ?? '#000000';
        ctx.lineWidth = Math.max(0, layer.outlineWidth ?? 0);
        if ((layer.outlineWidth ?? 0) > 0) {
          ctx.strokeText(layer.text ?? 'Text', -drawW / 2, 0);
        }
        ctx.fillText(layer.text ?? 'Text', -drawW / 2, 0);
        ctx.restore();
      }
    }

    ctx.restore();

    previewBusyRef.current = false;
    if (previewQueuedRef.current) {
      previewQueuedRef.current = false;
      requestAnimationFrame(() => { void renderPreviewFrame(); });
    }
  }, [audioEl, canvasSize, layers, resolveActiveClip, session.playhead]);

  useEffect(() => {
    void renderPreviewFrame();
  }, [renderPreviewFrame, session.playhead, layers, videoDurations, session.videoPaths]);

  useEffect(() => {
    const onResize = () => { void renderPreviewFrame(); };
    window.addEventListener('resize', onResize);
    return () => window.removeEventListener('resize', onResize);
  }, [renderPreviewFrame]);

  return (
    <div style={{ padding: 2 }}>
      <div className="grid">

        {/* Preview Row */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: '1px 0px' }}>PREVIEW</h2>
            <div style={{ marginLeft: 'auto' }}>

            
                <label style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', gap: 10, color: 'var(--text)', fontWeight: 600 }}>
                Theme
                <select 
                  value={theme}
                  onChange={(e) => {
                    const next = e.target.value === 'light' ? 'light' : 'dark';
                    setThemeChoice(next);
                  }}
                  style={{ background: 'var(--panel-alt)', color: 'var(--text)', fontSize: 16, fontFamily: "Tahoma", fontWeight: 200, border: '1px solid var(--border)', borderRadius: 8, margin: 'auto', padding: '6px 4px' }}
                >
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                </select>
              
              <button className="collapse-btn" type="button" onClick={() => toggleSection('preview')} aria-label="Toggle preview">
                <img src={assetHref(themedIcon(collapsed.preview ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.preview ? 'Expand' : 'Collapse'} />
              </button>
              </label>
              </div>
          </div>
          {!collapsed.preview && (
            <div className="section-body" style={{ padding: 0 }}>
              <canvas ref={previewCanvasRef} style={{ width: '100%', height: 320, display: 'block', borderRadius: 8, background: '#0b0f16' }} />
            </div>
          )}
        </div>

        {/* Media Row */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>MEDIA</h2>
            <button className="pill-btn" type="button" title="Load Audio" aria-label="Load Audio" onClick={handleBrowseAudio}>
              <img className="pill-btn__img" src={assetHref('ui/icon-audio-load.png')} alt="" />
              <span className="pill-btn__label">Load Audio</span>
            </button>
            <PillIconButton icon="ui/icon-video-add.png" label="Browse" onClick={handleBrowseVideos} />
            <PillIconButton icon="ui/icon-video.png" label="From Library" onClick={() => setAddVideoModalOpen(true)} />

            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 8 }}>
              <VolumeSlider value={volume} onChange={(v) => setVolume(Math.min(1, Math.max(0, v)))} width={180} />
              <div className="pill-btn" role="group" aria-label="Timeline zoom">
                <button className="pill-btn" style={{ border: '0px', padding: '0px' }} type="button" onClick={() => { setTimelineZoom((z) => Math.max(0.25, z / 2)); setTimelineScroll(0); }} aria-label="Zoom out">
                  <img className="pill-btn__img" src={assetHref('ui/icon-zoom-minus.png')} alt="" />
                </button>
                <span className="muted" style={{ minWidth: 60, lineHeight: 0.6, textAlign: 'center' }}>{Math.round(timelineZoom * 100)}%</span>
                <button className="pill-btn" style={{ border: '0px', padding: '0px' }} type="button" onClick={() => { setTimelineZoom((z) => Math.min(8, z * 2)); setTimelineScroll(0); }} aria-label="Zoom in">
                  <img className="pill-btn__img" src={assetHref('ui/icon-zoom-plus.png')} alt="" />
                </button>
              </div>
              <button className="pill-btn" type="button" onClick={() => { setTimelineZoom(1); setTimelineScroll(0); }}>
                <img className="pill-btn__img" src={assetHref('ui/icon-zoom-fit.png')} alt="" />
                <span className="pill-btn__label">Fit</span>
              </button>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('audio')} aria-label="Toggle media">
                <img src={assetHref(themedIcon(collapsed.audio ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.audio ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>
          {!collapsed.audio && (
            <div className="section-body" style={{ padding: 0, position: 'relative', overflow: 'hidden' }}>
              <div style={{ position: 'relative' }}>
                <OverviewWaveform
                  duration={audioDuration}
                  playhead={session.playhead ?? 0}
                  onSeek={(t: number) => setSession((prev) => ({ ...prev, playhead: t }))}
                  peaks={overviewPeaks}
                  hasAudio={!!session.audioPath}
                  zoom={timelineZoom}
                  scroll={timelineScroll}
                  onEmptyClick={handleBrowseAudio}
                />
                <div style={{ position: 'absolute', left: 8, top: 6, flexDirection: 'column' }}>
                  <button className="pill-btn pill-btn--compact" style={{ position: 'relative', top: '25px', width: '60px', height: '60px', borderRadius: '20px' }} type="button" title={isPlaying ? 'Pause' : 'Play'} aria-label={isPlaying ? 'Pause' : 'Play'} onClick={() => waveRef.current?.toggle()} disabled={!session.audioPath}>
                    <img className="pill-btn__img" style={{ position: 'relative', top: '0px', width: '45px', height: '45px' }} src={assetHref(isPlaying ? 'ui/icon-audio-pause.png' : 'ui/icon-audio-play.png')} alt="" />
                  </button>
                </div>

                <div className="time-pill" style={{ position: 'absolute', right: 8, bottom: 6 }}>
                  <span>{Math.floor(session.playhead ?? 0)}s</span>
                  <span>/</span>
                  <span>{Math.floor(audioDuration)}s</span>
                </div>
                <Waveform
                  ref={waveRef as any}
                  srcPath={session.audioPath ?? ''}
                  playhead={session.playhead ?? 0}
                  onPlayheadChange={(t) => setSession((prev) => ({ ...prev, playhead: t }))}
                  onDurationChange={(d) => setAudioDuration(d)}
                  onPlayingChange={(p) => setIsPlaying(p)}
                  volume={volume}
                  useElementVolume={false}
                  hideBuiltInControls
                  hideCanvas
                  onAudioElement={(el) => { setAudioEl(el); }}
                />
              </div>
              <div style={{ marginTop: 4 }}>
                {(session.videoPaths?.length ?? 0) > 0 ? (
                  <Storyboard
                    segments={clipSegments.map((seg, idx) => ({
                      id: seg.id,
                      path: seg.path,
                      index: idx,
                      label: clipNames[seg.path] ?? seg.path,
                      duration: seg.duration,
                      start: seg.start ?? 0,
                      trimStart: seg.trimStart,
                      trimEnd: seg.trimEnd,
                      sourceDuration: seg.sourceDuration,
                      missing: missingPaths.has(seg.path),
                    }))}
                    totalDuration={timelineDuration}
                    zoom={timelineZoom}
                    scroll={timelineScroll}
                    playhead={session.playhead ?? 0}
                    theme={theme}
                    onReorder={handleReorderClips}
                    onRemove={removeClipAt}
                    onTrimChange={(id, trimStart, duration) => applyTrimEdit(id, trimStart, duration)}
                    onDurationChange={(id, duration) => applyDurationEdit(id, duration)}
                    onContextMenu={(seg, x, y) => openClipContextMenu(seg.id, seg.path, seg.index, x, y)}
                    onDoubleClick={(seg) => handleClipEdit(seg.id, seg.path, seg.index)}
                  />
                ) : (
                  <div className="muted" style={{ marginTop: 2 }}>No clips. Use Browse or From Library to include files.</div>
                )}
              </div>
              {session.audioPath && (
                <div style={{ marginTop: 4, padding: '2px 8px' }}>
                  <div style={{ height: 12, background: '#1e2432', borderRadius: 6, position: 'relative' }} onClick={(e) => {
                    const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect();
                    const pct = Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
                    setTimelineScroll(pct);
                  }}>
                    <div
                      style={{
                        position: 'absolute',
                        left: `${Math.min(1, Math.max(0, timelineScroll)) * Math.max(0, 1 - 1 / Math.max(1, timelineZoom)) * 100}%`,
                        top: 2,
                        height: 8,
                        width: `${Math.min(100, (1 / Math.max(1, timelineZoom)) * 100)}%`,
                        background: '#3f51b5',
                        borderRadius: 4,
                        cursor: 'pointer',
                      }}
                      onMouseDown={(e) => {
                        e.preventDefault();
                        const onMove = (ev: MouseEvent) => {
                          const rect = (e.currentTarget!.parentElement as HTMLDivElement).getBoundingClientRect();
                          const pct = Math.min(1, Math.max(0, (ev.clientX - rect.left) / rect.width));
                          setTimelineScroll(pct);
                        };
                        const onUp = () => {
                          window.removeEventListener('mousemove', onMove);
                          window.removeEventListener('mouseup', onUp);
                        };
                        window.addEventListener('mousemove', onMove);
                        window.addEventListener('mouseup', onUp);
                      }}
                    />
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Layers Row */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>LAYERS</h2>
            <PillIconButton icon="ui/icon-layer-visualizer-add.png" label="Visualizer" onClick={() => startNewLayer('spectrograph')} />
            <PillIconButton icon="ui/icon-layer-text-add.png" label="Text" onClick={() => startNewLayer('text')} />
            <PillIconButton icon="ui/icon-folder.png" label="Image" onClick={() => startNewLayer('image')} />
            <PillIconButton icon="ui/icon-sliders.png" label="Particles" onClick={() => startNewLayer('particles')} />
            <div style={{ marginLeft: 'auto' }}>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('layers')} aria-label="Toggle layers">
                <img src={assetHref(themedIcon(collapsed.layers ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.layers ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>
          {!collapsed.layers && (
            <div className="section-body">
              {layers.length === 0 && <div className="muted">No layers yet. Add spectrograph or text overlays to render on top of the video.</div>}
              {layers.length > 0 && (
                <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                  {layers.map((layer) => (
                    <div
                      key={layer.id}
                      onClick={() => openEditLayer(layer)}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 10,
                        padding: '8px 10px',
                        background: selectedLayerId === layer.id ? hexToRgba(layer.color, 0.16) : 'var(--panel-alt)',
                        border: `1px solid ${selectedLayerId === layer.id ? hexToRgba(layer.color, 0.45) : 'var(--border)'}`,
                        borderRadius: 8,
                        cursor: 'pointer',
                      }}
                    >
                      <div style={{ width: 16, height: 16, borderRadius: 4, background: layer.color }} />
                      <div style={{ flex: 1 }}>
                        <div style={{ fontWeight: 600 }}>
                          {layer.type === 'text'
                            ? 'Text Layer'
                            : layer.type === 'image'
                              ? 'Image Layer'
                              : layer.type === 'particles'
                                ? 'Particles Layer'
                                : 'Spectrograph Layer'}
                        </div>
                        <div className="muted" style={{ fontSize: 12 }}>
                          {layer.type === 'text'
                            ? `Text: ${(layer as any).text ?? ''} @ (${Math.round(layer.x * 100)}%, ${Math.round(layer.y * 100)}%), font ${(layer as any).font ?? ''} ${(layer as any).fontSize ?? ''}`
                            : layer.type === 'image'
                              ? `Image: ${(layer as any).imagePath ? ((layer as any).imagePath as string).split(/[\\/]/).pop() : 'None'} @ (${Math.round(layer.x * 100)}%, ${Math.round(layer.y * 100)}%)`
                              : layer.type === 'particles'
                                ? `Particles @ (${Math.round(layer.x * 100)}%, ${Math.round(layer.y * 100)}%)`
                                : `Mode: ${(layer as any).mode ?? 'bar'} @ (${Math.round(layer.x * 100)}%, ${Math.round(layer.y * 100)}%)`}
                        </div>
                      </div>
                      <button className="pill-btn" type="button" onClick={(e) => { e.stopPropagation(); openEditLayer(layer); }}>Edit</button>
                      <button className="pill-btn" type="button" onClick={(e) => { e.stopPropagation(); duplicateLayer(layer); }}>Duplicate</button>
                      <button className="pill-btn" type="button" onClick={(e) => { e.stopPropagation(); deleteLayer(layer.id); }}>Delete</button>
                    </div>
                  ))}
                </div>
              )}
              {layerDialogOpen && (
                <div className="panel" style={{ marginTop: 10, padding: 12, background: selectedLayer ? hexToRgba(selectedLayer.color, 0.12) : 'var(--panel-alt)', borderColor: selectedLayer ? hexToRgba(selectedLayer.color, 0.35) : 'var(--border)' }}>
                  <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Type
                      <select
                        className="pill-select"
                        value={layerDraft.type ?? 'spectrograph'}
                        onChange={(e) => {
                          const nextType = e.target.value as LayerType;
                          setLayerDraft((prev) => ({
                            ...prev,
                            type: nextType,
                            mode: nextType === 'spectrograph' ? (prev.mode as any) ?? 'bar' : undefined,
                            pathMode: nextType === 'spectrograph' ? (prev.pathMode as any) ?? 'straight' : undefined,
                            barCount: nextType === 'spectrograph' ? (prev.barCount ?? 96) : undefined,
                            barWidthPct: nextType === 'spectrograph' ? (prev.barWidthPct ?? 0.8) : undefined,
                            dotCount: nextType === 'spectrograph' ? (prev.dotCount ?? 96) : undefined,
                            solidPointCount: nextType === 'spectrograph' ? (prev.solidPointCount ?? 96) : undefined,
                            freqScale: nextType === 'spectrograph' ? (prev.freqScale ?? 'log') : undefined,
                            ampScale: nextType === 'spectrograph' ? (prev.ampScale ?? 'log') : undefined,
                            averaging: nextType === 'spectrograph' ? (prev.averaging ?? 2) : undefined,
                            mirrorX: nextType === 'spectrograph' ? (prev.mirrorX ?? false) : undefined,
                            mirrorY: nextType === 'spectrograph' ? (prev.mirrorY ?? false) : undefined,
                            text: nextType === 'text' ? (prev.text ?? 'Text') : undefined,
                            font: nextType === 'text' ? (prev.font ?? 'Segoe UI') : undefined,
                            fontSize: nextType === 'text' ? (prev.fontSize ?? 12) : undefined,
                            imagePath: nextType === 'image' ? (prev.imagePath ?? '') : undefined,
                            motionAffected: nextType === 'image' ? (prev.motionAffected ?? true) : undefined,
                            direction: nextType === 'particles' ? (prev.direction ?? 0) : undefined,
                            speed: nextType === 'particles' ? (prev.speed ?? 60) : undefined,
                            sizeMin: nextType === 'particles' ? (prev.sizeMin ?? 2) : undefined,
                            sizeMax: nextType === 'particles' ? (prev.sizeMax ?? 6) : undefined,
                            opacityMin: nextType === 'particles' ? (prev.opacityMin ?? 0.3) : undefined,
                            opacityMax: nextType === 'particles' ? (prev.opacityMax ?? 0.9) : undefined,
                            audioResponsive: nextType === 'particles' ? (prev.audioResponsive ?? true) : undefined,
                            particleCount: nextType === 'particles' ? (prev.particleCount ?? 200) : undefined,
                          }));
                        }}
                      >
                        <option value="spectrograph">Standard Spectrograph</option>
                        <option value="text">Text</option>
                        <option value="image">Image</option>
                        <option value="particles">Particles</option>
                      </select>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Color
                      <input type="color" value={layerDraft.color ?? '#ffffff'} onChange={(e) => updateLayerDraftField({ color: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Outline Color
                      <input type="color" value={layerDraft.outlineColor ?? '#000000'} onChange={(e) => updateLayerDraftField({ outlineColor: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Outline Width
                      <input type="range" min={0} max={20} value={layerDraft.outlineWidth ?? 0} onChange={(e) => updateLayerDraftField({ outlineWidth: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Outline Width (px)', layerDraft.outlineWidth ?? 0, 0, 20, (v) => updateLayerDraftField({ outlineWidth: v }))}
                      >
                        {layerDraft.outlineWidth ?? 0}px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Glow Color
                      <input type="color" value={layerDraft.glowColor ?? '#ffffff'} onChange={(e) => updateLayerDraftField({ glowColor: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Glow Amount
                      <input type="range" min={0} max={50} value={layerDraft.glowAmount ?? 0} onChange={(e) => updateLayerDraftField({ glowAmount: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Glow Amount (px)', layerDraft.glowAmount ?? 0, 0, 50, (v) => updateLayerDraftField({ glowAmount: v }))}
                      >
                        {layerDraft.glowAmount ?? 0}px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Glow Opacity
                      <input type="range" min={0} max={1} step={0.05} value={layerDraft.glowOpacity ?? 0.4} onChange={(e) => updateLayerDraftField({ glowOpacity: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Glow Opacity (0..1)', layerDraft.glowOpacity ?? 0.4, 0, 1, (v) => updateLayerDraftField({ glowOpacity: v }))}
                      >
                        {(layerDraft.glowOpacity ?? 0.4).toFixed(2)}
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Shadow Color
                      <input type="color" value={layerDraft.shadowColor ?? '#000000'} onChange={(e) => updateLayerDraftField({ shadowColor: e.target.value })} />
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Shadow Distance
                      <input type="range" min={0} max={50} value={layerDraft.shadowDistance ?? 0} onChange={(e) => updateLayerDraftField({ shadowDistance: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Shadow Distance (px)', layerDraft.shadowDistance ?? 0, 0, 50, (v) => updateLayerDraftField({ shadowDistance: v }))}
                      >
                        {layerDraft.shadowDistance ?? 0}px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      X (%)
                      <input type="range" min={-100} max={100} value={Math.round((layerDraft.x ?? 0) * 100)} onChange={(e) => updateLayerDraftField({ x: Math.min(100, Math.max(-100, Number(e.target.value))) / 100 })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('X (%)', Math.round((layerDraft.x ?? 0) * 100), -100, 100, (v) => updateLayerDraftField({ x: v / 100 }))}
                      >
                        {Math.round((layerDraft.x ?? 0) * 100)}%
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Y (%)
                      <input type="range" min={-100} max={100} value={Math.round((layerDraft.y ?? 0) * 100)} onChange={(e) => updateLayerDraftField({ y: Math.min(100, Math.max(-100, Number(e.target.value))) / 100 })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Y (%)', Math.round((layerDraft.y ?? 0) * 100), -100, 100, (v) => updateLayerDraftField({ y: v / 100 }))}
                      >
                        {Math.round((layerDraft.y ?? 0) * 100)}%
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Rotate
                      <input type="range" min={0} max={360} value={Math.round(layerDraft.rotate ?? 0)} onChange={(e) => updateLayerDraftField({ rotate: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Rotate (deg)', Math.round(layerDraft.rotate ?? 0), 0, 360, (v) => updateLayerDraftField({ rotate: v }))}
                      >
                        {Math.round(layerDraft.rotate ?? 0)}deg
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Transparency
                      <input type="range" min={0} max={100} value={Math.round((layerDraft.opacity ?? 1) * 100)} onChange={(e) => updateLayerDraftField({ opacity: Math.min(100, Math.max(0, Number(e.target.value))) / 100 })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Transparency (%)', Math.round((layerDraft.opacity ?? 1) * 100), 0, 100, (v) => updateLayerDraftField({ opacity: v / 100 }))}
                      >
                        {Math.round((layerDraft.opacity ?? 1) * 100)}%
                      </span>
                    </label>
                    {layerDraft.type === 'spectrograph' && (
                      <>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Path
                          <select
                            className="pill-select"
                            value={layerDraft.pathMode ?? 'straight'}
                            onChange={(e) => updateLayerDraftField({ pathMode: e.target.value as 'straight' | 'circular' })}
                          >
                            <option value="straight">Straight</option>
                            <option value="circular">Circular</option>
                          </select>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Frequency Scale
                          <select
                            className="pill-select"
                            value={layerDraft.freqScale ?? 'log'}
                            onChange={(e) => updateLayerDraftField({ freqScale: e.target.value as 'lin' | 'log' | 'rlog' })}
                          >
                            <option value="lin">Linear</option>
                            <option value="log">Log</option>
                            <option value="rlog">Reverse Log</option>
                          </select>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Amplitude Scale
                          <select
                            className="pill-select"
                            value={layerDraft.ampScale ?? 'log'}
                            onChange={(e) => updateLayerDraftField({ ampScale: e.target.value as 'lin' | 'sqrt' | 'cbrt' | 'log' })}
                          >
                            <option value="lin">Linear</option>
                            <option value="sqrt">Sqrt</option>
                            <option value="cbrt">Cbrt</option>
                            <option value="log">Log</option>
                          </select>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Averaging
                          <input type="range" min={1} max={10} value={layerDraft.averaging ?? 2} onChange={(e) => updateLayerDraftField({ averaging: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Averaging', layerDraft.averaging ?? 2, 1, 10, (v) => updateLayerDraftField({ averaging: v }))}
                          >
                            {layerDraft.averaging ?? 2}
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Mirror X
                          <button
                            className="pill-btn"
                            type="button"
                            aria-pressed={!!layerDraft.mirrorX}
                            onClick={() => updateLayerDraftField({ mirrorX: !layerDraft.mirrorX })}
                          >
                            <span>{layerDraft.mirrorX ? 'On' : 'Off'}</span>
                          </button>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Mirror Y
                          <button
                            className="pill-btn"
                            type="button"
                            aria-pressed={!!layerDraft.mirrorY}
                            onClick={() => updateLayerDraftField({ mirrorY: !layerDraft.mirrorY })}
                          >
                            <span>{layerDraft.mirrorY ? 'On' : 'Off'}</span>
                          </button>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Mode
                          <select
                            className="pill-select"
                        value={layerDraft.mode ?? 'bar'}
                        onChange={(e) => updateLayerDraftField({ mode: e.target.value as 'bar' | 'line' | 'solid' | 'dots' })}
                      >
                        <option value="bar">Bar</option>
                        <option value="line">Line</option>
                        <option value="solid">Solid</option>
                        <option value="dots">Dots</option>
                      </select>
                    </label>
                    {(layerDraft.mode ?? 'bar') === 'bar' && (
                      <>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Bar Count
                          <input type="range" min={8} max={256} value={layerDraft.barCount ?? 96} onChange={(e) => updateLayerDraftField({ barCount: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Bar Count', layerDraft.barCount ?? 96, 8, 256, (v) => updateLayerDraftField({ barCount: v }))}
                          >
                            {layerDraft.barCount ?? 96}
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Bar Width (%)
                          <input type="range" min={10} max={100} value={Math.round((layerDraft.barWidthPct ?? 0.8) * 100)} onChange={(e) => updateLayerDraftField({ barWidthPct: Number(e.target.value) / 100 })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Bar Width (%)', Math.round((layerDraft.barWidthPct ?? 0.8) * 100), 10, 100, (v) => updateLayerDraftField({ barWidthPct: v / 100 }))}
                          >
                            {Math.round((layerDraft.barWidthPct ?? 0.8) * 100)}%
                          </span>
                        </label>
                      </>
                    )}
                    {(layerDraft.mode ?? 'bar') === 'dots' && (
                      <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                        Dot Count
                        <input type="range" min={8} max={256} value={layerDraft.dotCount ?? 96} onChange={(e) => updateLayerDraftField({ dotCount: Number(e.target.value) })} />
                        <span
                          className="muted"
                          style={{ fontSize: 12 }}
                          onDoubleClick={() => promptNumeric('Dot Count', layerDraft.dotCount ?? 96, 8, 256, (v) => updateLayerDraftField({ dotCount: v }))}
                        >
                          {layerDraft.dotCount ?? 96}
                        </span>
                      </label>
                    )}
                    {(layerDraft.mode ?? 'bar') === 'solid' && (
                      <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                        Solid Points
                        <input type="range" min={8} max={256} value={layerDraft.solidPointCount ?? 96} onChange={(e) => updateLayerDraftField({ solidPointCount: Number(e.target.value) })} />
                        <span
                          className="muted"
                          style={{ fontSize: 12 }}
                          onDoubleClick={() => promptNumeric('Solid Points', layerDraft.solidPointCount ?? 96, 8, 256, (v) => updateLayerDraftField({ solidPointCount: v }))}
                        >
                          {layerDraft.solidPointCount ?? 96}
                        </span>
                      </label>
                    )}
                  </>
                )}
                {layerDraft.type === 'spectrograph' && (
                  <>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Width (px)
                      <input type="range" min={50} max={4000} value={Math.round(layerDraft.width ?? canvasSize.width)} onChange={(e) => updateLayerDraftField({ width: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Width (px)', Math.round(layerDraft.width ?? canvasSize.width), 50, 4000, (v) => updateLayerDraftField({ width: v }))}
                      >
                        {Math.round(layerDraft.width ?? canvasSize.width)} px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Height (px)
                      <input type="range" min={50} max={3000} value={Math.round(layerDraft.height ?? canvasSize.height)} onChange={(e) => updateLayerDraftField({ height: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Height (px)', Math.round(layerDraft.height ?? canvasSize.height), 50, 3000, (v) => updateLayerDraftField({ height: v }))}
                      >
                        {Math.round(layerDraft.height ?? canvasSize.height)} px
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Invert
                      <button
                        className="pill-btn"
                        type="button"
                        aria-pressed={!!layerDraft.invert}
                        onClick={() => updateLayerDraftField({ invert: !layerDraft.invert })}
                      >
                        <span>{layerDraft.invert ? 'On' : 'Off'}</span>
                      </button>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Reverse
                      <button
                        className="pill-btn"
                        type="button"
                        aria-pressed={!!layerDraft.reverse}
                        onClick={() => updateLayerDraftField({ reverse: !layerDraft.reverse })}
                      >
                        <span>{layerDraft.reverse ? 'On' : 'Off'}</span>
                      </button>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      Low Cut (Hz)
                      <input type="range" min={10} max={500} value={layerDraft.lowCutHz ?? 40} onChange={(e) => updateLayerDraftField({ lowCutHz: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('Low Cut (Hz)', layerDraft.lowCutHz ?? 40, 10, 500, (v) => updateLayerDraftField({ lowCutHz: v }))}
                      >
                        {layerDraft.lowCutHz ?? 40} Hz
                      </span>
                    </label>
                    <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      High Cut (Hz)
                      <input type="range" min={2000} max={20000} step={100} value={layerDraft.highCutHz ?? 16000} onChange={(e) => updateLayerDraftField({ highCutHz: Number(e.target.value) })} />
                      <span
                        className="muted"
                        style={{ fontSize: 12 }}
                        onDoubleClick={() => promptNumeric('High Cut (Hz)', layerDraft.highCutHz ?? 16000, 2000, 20000, (v) => updateLayerDraftField({ highCutHz: v }))}
                      >
                        {layerDraft.highCutHz ?? 16000} Hz
                      </span>
                    </label>
                  </>
                    )}
                    {layerDraft.type === 'image' && (
                      <>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4, minWidth: 240 }}>
                          Image File
                          <input type="text" value={layerDraft.imagePath ?? ''} readOnly />
                          <button className="pill-btn" type="button" onClick={handlePickImageForLayer}>
                            <span>Browse</span>
                          </button>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Width (px)
                          <input type="range" min={20} max={4000} value={Math.round(layerDraft.width ?? 320)} onChange={(e) => updateLayerDraftField({ width: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Width (px)', Math.round(layerDraft.width ?? 320), 20, 4000, (v) => updateLayerDraftField({ width: v }))}
                          >
                            {Math.round(layerDraft.width ?? 320)} px
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Height (px)
                          <input type="range" min={20} max={3000} value={Math.round(layerDraft.height ?? 320)} onChange={(e) => updateLayerDraftField({ height: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Height (px)', Math.round(layerDraft.height ?? 320), 20, 3000, (v) => updateLayerDraftField({ height: v }))}
                          >
                            {Math.round(layerDraft.height ?? 320)} px
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Invert
                          <button
                            className="pill-btn"
                            type="button"
                            aria-pressed={!!layerDraft.invert}
                            onClick={() => updateLayerDraftField({ invert: !layerDraft.invert })}
                          >
                            <span>{layerDraft.invert ? 'On' : 'Off'}</span>
                          </button>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Reverse
                          <button
                            className="pill-btn"
                            type="button"
                            aria-pressed={!!layerDraft.reverse}
                            onClick={() => updateLayerDraftField({ reverse: !layerDraft.reverse })}
                          >
                            <span>{layerDraft.reverse ? 'On' : 'Off'}</span>
                          </button>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Motion Affected
                          <button
                            className="pill-btn"
                            type="button"
                            aria-pressed={!!layerDraft.motionAffected}
                            onClick={() => updateLayerDraftField({ motionAffected: !layerDraft.motionAffected })}
                          >
                            <span>{layerDraft.motionAffected ? 'On' : 'Off'}</span>
                          </button>
                        </label>
                      </>
                    )}
                    {layerDraft.type === 'particles' && (
                      <>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Direction (deg)
                          <input type="range" min={0} max={360} value={Math.round(layerDraft.direction ?? 0)} onChange={(e) => updateLayerDraftField({ direction: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Direction (deg)', Math.round(layerDraft.direction ?? 0), 0, 360, (v) => updateLayerDraftField({ direction: v }))}
                          >
                            {Math.round(layerDraft.direction ?? 0)}deg
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Speed
                          <input type="range" min={0} max={300} value={Math.round(layerDraft.speed ?? 60)} onChange={(e) => updateLayerDraftField({ speed: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Speed', Math.round(layerDraft.speed ?? 60), 0, 300, (v) => updateLayerDraftField({ speed: v }))}
                          >
                            {Math.round(layerDraft.speed ?? 60)}
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Size Min (px)
                          <input type="range" min={1} max={50} value={Math.round(layerDraft.sizeMin ?? 2)} onChange={(e) => updateLayerDraftField({ sizeMin: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Size Min (px)', Math.round(layerDraft.sizeMin ?? 2), 1, 50, (v) => updateLayerDraftField({ sizeMin: v }))}
                          >
                            {Math.round(layerDraft.sizeMin ?? 2)} px
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Size Max (px)
                          <input type="range" min={1} max={80} value={Math.round(layerDraft.sizeMax ?? 6)} onChange={(e) => updateLayerDraftField({ sizeMax: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Size Max (px)', Math.round(layerDraft.sizeMax ?? 6), 1, 80, (v) => updateLayerDraftField({ sizeMax: v }))}
                          >
                            {Math.round(layerDraft.sizeMax ?? 6)} px
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Opacity Min
                          <input type="range" min={0} max={100} value={Math.round((layerDraft.opacityMin ?? 0.3) * 100)} onChange={(e) => updateLayerDraftField({ opacityMin: Number(e.target.value) / 100 })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Opacity Min (%)', Math.round((layerDraft.opacityMin ?? 0.3) * 100), 0, 100, (v) => updateLayerDraftField({ opacityMin: v / 100 }))}
                          >
                            {Math.round((layerDraft.opacityMin ?? 0.3) * 100)}%
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Opacity Max
                          <input type="range" min={0} max={100} value={Math.round((layerDraft.opacityMax ?? 0.9) * 100)} onChange={(e) => updateLayerDraftField({ opacityMax: Number(e.target.value) / 100 })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Opacity Max (%)', Math.round((layerDraft.opacityMax ?? 0.9) * 100), 0, 100, (v) => updateLayerDraftField({ opacityMax: v / 100 }))}
                          >
                            {Math.round((layerDraft.opacityMax ?? 0.9) * 100)}%
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Particle Count
                          <input type="range" min={10} max={1000} value={Math.round(layerDraft.particleCount ?? 200)} onChange={(e) => updateLayerDraftField({ particleCount: Number(e.target.value) })} />
                          <span
                            className="muted"
                            style={{ fontSize: 12 }}
                            onDoubleClick={() => promptNumeric('Particle Count', Math.round(layerDraft.particleCount ?? 200), 10, 1000, (v) => updateLayerDraftField({ particleCount: v }))}
                          >
                            {Math.round(layerDraft.particleCount ?? 200)}
                          </span>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Audio Responsive
                          <button
                            className="pill-btn"
                            type="button"
                            aria-pressed={!!layerDraft.audioResponsive}
                            onClick={() => updateLayerDraftField({ audioResponsive: !layerDraft.audioResponsive })}
                          >
                            <span>{layerDraft.audioResponsive ? 'On' : 'Off'}</span>
                          </button>
                        </label>
                      </>
                    )}
                    {layerDraft.type === 'text' && (
                      <>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Text
                          <input type="text" value={layerDraft.text ?? ''} onChange={(e) => updateLayerDraftField({ text: e.target.value })} />
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Font
                          <select
                            className="pill-btn"
                            value={layerDraft.font ?? 'Segoe UI'}
                            onChange={(e) => updateLayerDraftField({ font: e.target.value })}
                            style={{ height: 34, padding: '0 12px' }}
                          >
                            {(() => {
                              const current = layerDraft.font ?? 'Segoe UI';
                              const options = FONT_FACE_OPTIONS.includes(current)
                                ? FONT_FACE_OPTIONS
                                : [current, ...FONT_FACE_OPTIONS];
                              return options.map((name) => (
                                <option value={name} key={name}>{name}</option>
                              ));
                            })()}
                          </select>
                        </label>
                        <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                          Font Size
                          <input type="range" min={8} max={96} value={layerDraft.fontSize ?? 12} onChange={(e) => updateLayerDraftField({ fontSize: Number(e.target.value) })} />
                          <span className="muted" style={{ fontSize: 12 }}>{layerDraft.fontSize ?? 12}px</span>
                        </label>
                      </>
                    )}
                  </div>
                  <div style={{ marginTop: 12, display: 'flex', gap: 8, justifyContent: 'flex-end' }}>
                    <button className="pill-btn" type="button" onClick={() => { setLayerDialogOpen(false); }}>Cancel</button>
                    <button className="pill-btn" type="button" onClick={saveLayerDraft}>OK</button>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Media Library */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>MEDIA LIBRARY</h2>
            <button className="pill-btn" type="button" onClick={() => setAddVideoModalOpen(true)}>
              <span>Add Entry</span>
            </button>
            <button className="pill-btn" type="button" disabled={!librarySelectedId} onClick={async () => {
              if (!librarySelectedId) return;
              const next = library.filter((i) => i.id !== librarySelectedId);
              await saveLibrary(next);
              setLibrarySelectedId(null);
            }}>
              <span>Remove</span>
            </button>
            <div style={{ marginLeft: 'auto' }}>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('library')} aria-label="Toggle library">
                <img src={assetHref(themedIcon(collapsed.library ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.library ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>
          {!collapsed.library && (
            <div className="section-body">
              {library.length === 0 && <div className="muted">No items in library.</div>}
              {library.length > 0 && (
                <>
                  <div style={{ maxHeight: 200, overflow: 'auto', border: '1px solid var(--border)', borderRadius: 6 }}>
                    {library.map((item) => (
                      <div
                        key={item.id}
                        onClick={() => setLibrarySelectedId(item.id)}
                        style={{
                          padding: '6px 8px',
                          cursor: 'pointer',
                          background: missingPaths.has(item.path)
                            ? '#4a2a2a'
                            : (librarySelectedId === item.id ? 'var(--panel-alt)' : 'transparent'),
                          borderBottom: '1px solid var(--border)',
                        }}
                      >
                        <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                          <button
                            className="pill-btn pill-btn--compact"
                            type="button"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleAddVideoFromLibrary(item);
                            }}
                          >
                            Add
                          </button>
                          <div style={{ flex: 1 }}>
                            <div style={{ fontWeight: 600 }}>{item.name}</div>
                            <div className="muted" style={{ fontSize: 12 }}>{item.path}</div>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                  {librarySelectedId && (() => {
                    const sel = library.find((i) => i.id === librarySelectedId);
                    if (!sel) return null;
                    return (
                      <div style={{ marginTop: 8, padding: 8, border: '1px solid var(--border)', borderRadius: 6 }}>
                        <div style={{ fontWeight: 700, marginBottom: 4 }}>{sel.name}</div>
                        {sel.description && <div className="muted">{sel.description}</div>}
                        <div className="muted" style={{ fontSize: 12 }}>Path: {sel.path}</div>
                        <div className="muted" style={{ fontSize: 12 }}>Duration: {sel.duration ? `${Math.round(sel.duration)}s` : 'n/a'}</div>
                        <div className="muted" style={{ fontSize: 12 }}>Video: {sel.videoCodec ?? 'n/a'} {sel.width && sel.height ? `(${sel.width}x${sel.height})` : ''}</div>
                        <div className="muted" style={{ fontSize: 12 }}>Audio: {sel.audioCodec ?? 'n/a'} {sel.audioChannels ? `(${sel.audioChannels}ch)` : ''}</div>
                      </div>
                    );
                  })()}
                </>
              )}
            </div>
          )}
        </div>



        {addVideoModalOpen && (
          <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}>
            <div style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 8, padding: 16, width: 520, maxHeight: '70vh', overflow: 'auto' }}>
              <h3 style={{ marginTop: 0 }}>Add Video</h3>
              <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap', marginBottom: 12 }}>
                <button className="pill-btn" type="button" onClick={() => { setCollapsed((prev) => ({ ...prev, library: false })); }}>
                  <span>Pick From Library Below</span>
                </button>
                <button className="pill-btn" type="button" onClick={handleBrowseAndAddToLibrary}>
                  <span>Browse Files</span>
                </button>
                <button className="pill-btn" type="button" onClick={() => setAddVideoModalOpen(false)}>
                  <span>Close</span>
                </button>
              </div>
              <div style={{ maxHeight: 300, overflow: 'auto', border: '1px solid var(--border)', borderRadius: 6 }}>
                {library.map((item) => (
                  <div
                    key={item.id}
                    onClick={() => setLibrarySelectedId(item.id)}
                    onDoubleClick={() => handleAddVideoFromLibrary(item)}
                    style={{
                      padding: '6px 8px',
                      cursor: 'pointer',
                      background: librarySelectedId === item.id ? 'var(--panel-alt)' : 'transparent',
                      borderBottom: '1px solid var(--border)',
                    }}
                  >
                    <div style={{ fontWeight: 600 }}>{item.name}</div>
                    <div className="muted" style={{ fontSize: 12 }}>{item.path}</div>
                  </div>
                ))}
              </div>
              <div style={{ display: 'flex', gap: 8, marginTop: 10 }}>
                <button className="pill-btn" type="button" disabled={!librarySelectedId} onClick={() => {
                  const sel = library.find((i) => i.id === librarySelectedId);
                  if (sel) handleAddVideoFromLibrary(sel);
                }}>
                  <span>Use Selected</span>
                </button>
              </div>
            </div>
          </div>
        )}

        {clipEditor && clipEditorDraft && (
          <div
            style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1050 }}
            onClick={closeClipEditor}
          >
            <div
              style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 10, padding: 18, width: 620, maxWidth: '94vw' }}
              onClick={(e) => e.stopPropagation()}
            >
              <h3 style={{ marginTop: 0, marginBottom: 12 }}>Clip Properties</h3>
              <div style={{ display: 'grid', gridTemplateColumns: '150px 1fr', gap: 10 }}>
                <label style={{ fontWeight: 600 }}>Path</label>
                <input type="text" readOnly value={clipEditor.path} style={{ width: '100%' }} />
                <label style={{ fontWeight: 600 }}>Timeline Start</label>
                <input
                  type="number"
                  value={clipEditorDraft.timelineStart ?? 0}
                  min={0}
                  step={0.05}
                  onChange={(e) => {
                    const next = Number(e.target.value);
                    setClipEditorDraft((prev) => {
                      if (!prev) return prev;
                      const safeStart = Number.isFinite(next) ? Math.max(0, next) : 0;
                      const end = prev.timelineEnd ?? safeStart + (prev.duration ?? 0.05);
                      return { ...prev, timelineStart: safeStart, timelineEnd: Math.max(safeStart + 0.05, end) };
                    });
                  }}
                />
                <label style={{ fontWeight: 600 }}>Timeline End</label>
                <input
                  type="number"
                  value={clipEditorDraft.timelineEnd ?? 0}
                  min={0}
                  step={0.05}
                  onChange={(e) => {
                    const next = Number(e.target.value);
                    setClipEditorDraft((prev) => {
                      if (!prev) return prev;
                      const safeEnd = Number.isFinite(next) ? Math.max(0, next) : 0;
                      const start = prev.timelineStart ?? 0;
                      return { ...prev, timelineEnd: Math.max(start + 0.05, safeEnd) };
                    });
                  }}
                />
                <label style={{ fontWeight: 600 }}>Trim Start</label>
                <input
                  type="number"
                  value={clipEditorDraft.trimStart ?? 0}
                  min={0}
                  step={0.05}
                  onChange={(e) => {
                    const next = Number(e.target.value);
                    setClipEditorDraft((prev) => {
                      if (!prev) return prev;
                      const safeStart = Number.isFinite(next) ? Math.max(0, next) : 0;
                      const end = prev.trimEnd ?? safeStart + 0.05;
                      return { ...prev, trimStart: safeStart, trimEnd: Math.max(safeStart + 0.05, end) };
                    });
                  }}
                />
                <label style={{ fontWeight: 600 }}>Trim End</label>
                <input
                  type="number"
                  value={clipEditorDraft.trimEnd ?? 0}
                  min={0}
                  step={0.05}
                  onChange={(e) => {
                    const next = Number(e.target.value);
                    setClipEditorDraft((prev) => {
                      if (!prev) return prev;
                      const safeEnd = Number.isFinite(next) ? Math.max(0, next) : 0;
                      const start = prev.trimStart ?? 0;
                      return { ...prev, trimEnd: Math.max(start + 0.05, safeEnd) };
                    });
                  }}
                />
              </div>
              <div style={{ display: 'grid', gridTemplateColumns: '150px 1fr', gap: 10, marginTop: 14 }}>
                <label style={{ fontWeight: 600 }}>Hue</label>
                <input
                  type="number"
                  value={clipEditorDraft.hue ?? 0}
                  min={-180}
                  max={180}
                  step={1}
                  onChange={(e) => updateClipEditorDraft({ hue: Number(e.target.value) })}
                />
                <label style={{ fontWeight: 600 }}>Contrast</label>
                <input
                  type="number"
                  value={clipEditorDraft.contrast ?? 1}
                  min={0}
                  max={2}
                  step={0.05}
                  onChange={(e) => updateClipEditorDraft({ contrast: Number(e.target.value) })}
                />
                <label style={{ fontWeight: 600 }}>Brightness</label>
                <input
                  type="number"
                  value={clipEditorDraft.brightness ?? 1}
                  min={0}
                  max={2}
                  step={0.05}
                  onChange={(e) => updateClipEditorDraft({ brightness: Number(e.target.value) })}
                />
                <label style={{ fontWeight: 600 }}>Rotate</label>
                <input
                  type="number"
                  value={clipEditorDraft.rotate ?? 0}
                  min={0}
                  max={360}
                  step={1}
                  onChange={(e) => updateClipEditorDraft({ rotate: Number(e.target.value) })}
                />
                <label style={{ fontWeight: 600 }}>Flip / Invert</label>
                <div style={{ display: 'flex', gap: 8 }}>
                  <button
                    className="pill-btn pill-btn--compact"
                    type="button"
                    aria-pressed={!!clipEditorDraft.flipH}
                    onClick={() => updateClipEditorDraft({ flipH: !clipEditorDraft.flipH })}
                    style={{ borderColor: clipEditorDraft.flipH ? 'var(--accent)' : 'var(--border)' }}
                  >
                    <span>Flip H</span>
                  </button>
                  <button
                    className="pill-btn pill-btn--compact"
                    type="button"
                    aria-pressed={!!clipEditorDraft.flipV}
                    onClick={() => updateClipEditorDraft({ flipV: !clipEditorDraft.flipV })}
                    style={{ borderColor: clipEditorDraft.flipV ? 'var(--accent)' : 'var(--border)' }}
                  >
                    <span>Flip V</span>
                  </button>
                  <button
                    className="pill-btn pill-btn--compact"
                    type="button"
                    aria-pressed={!!clipEditorDraft.invert}
                    onClick={() => updateClipEditorDraft({ invert: !clipEditorDraft.invert })}
                    style={{ borderColor: clipEditorDraft.invert ? 'var(--accent)' : 'var(--border)' }}
                  >
                    <span>Invert</span>
                  </button>
                </div>
              </div>
              <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end', marginTop: 16 }}>
                <button className="pill-btn" type="button" onClick={closeClipEditor}>Cancel</button>
                <button className="pill-btn" type="button" onClick={applyClipEditor}>Save</button>
              </div>
            </div>
          </div>
        )}

        {licenseModalOpen && (
          <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1100 }} onClick={() => setLicenseModalOpen(false)}>
            <div style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 10, padding: 18, width: 560, maxWidth: '92vw' }} onClick={(e) => e.stopPropagation()}>
              <h3 style={{ marginTop: 0, marginBottom: 12 }}>Upgrade to Full Version</h3>
              <div style={{ display: 'grid', gridTemplateColumns: '160px 1fr', gap: 16, alignItems: 'center', marginBottom: 12 }}>
                <div style={{ background: '#0c1020', borderRadius: 10, padding: 8, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                  <img
                    src={assetHref('ui/muvidgen_setupWizard_logo.png')}
                    alt="Muvidgen logo"
                    style={{ width: '100%', maxWidth: 190, height: 'auto', display: 'block', objectFit: 'contain' }}
                  />
                </div>
                <div style={{ background: '#f3f4f6', color: '#111', borderRadius: 8, padding: 12, border: '1px solid #e5e7eb' }}>
                  <a href="https://muvidgen.sorryneedboost.com" target="_blank" rel="noopener noreferrer" style={{ textDecoration: 'underline', color: 'inherit', display: 'inline-block', fontFamily: 'Segoe UI, sans-serif' }}>
                    <strong style={{ fontSize: '1.1em', fontWeight: 700, color: '#000' }}>Purchase Here</strong>
                  </a>
                  <div style={{ fontStyle: 'italic', color: '#666', fontSize: '0.85em', marginTop: 6, lineHeight: 1.5, maxWidth: 500 }}>
                    Lifetime license that unlocks all current and future features for this generation of the muVid application.
                  </div>
                </div>
              </div>
              <label style={{ display: 'flex', flexDirection: 'row', gap: 6, marginBottom: 10 }}>
                <span style={{ fontWeight: 600, padding: '5px 10px 10px 10px' }}>Enter Product Key</span>
                <input
                  type="text"
                  value={licenseKeyInput}
                  onChange={(e) => setLicenseKeyInput(e.target.value)}
                  placeholder="XXXX-XXXX-XXXX-XXXX"
                  style={{ padding: '8px 10px', borderRadius: 6, textAlign: 'center', border: '1px solid var(--border)', background: 'var(--panel-alt)', color: 'var(--text)' }}
                />
              </label>
              {licenseError && <div style={{ color: '#c0392b', marginBottom: 10 }}>{licenseError}</div>}
              <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end' }}>
                <button className="pill-btn" type="button" onClick={() => setLicenseModalOpen(false)}>
                  <span>Close</span>
                </button>
                <button className="pill-btn" type="button" onClick={handleValidateLicense} disabled={validatingLicense}>
                  <span>{validatingLicense ? 'Checking...' : 'Activate'}</span>
                </button>
              </div>

            </div>
          </div>
        )}

        <div className="right section-block" style={{ opacity: projectLocked ? 0.45 : 1, pointerEvents: projectLocked ? 'none' : 'auto' }}>
          <div className="section-header">
            <h2 style={{ margin: 0 }}>PROJECT</h2>
                <button className="pill-btn" type="button" onClick={handleNewProject}>
                  <span>New</span>
                </button>
                <PillIconButton icon="ui/icon-project-load.png" label="Load" onClick={handleLoadProject} disabled={projectLocked} title={projectLocked ? 'Available in full version' : undefined} />
                <PillIconButton icon="ui/icon-project-save-as.png" label="Save As" onClick={handleSaveProjectAs} disabled={projectLocked} title={projectLocked ? 'Available in full version' : undefined} />
                <PillIconButton icon="ui/icon-project-save.png" label="Save" onClick={handleSaveProject} disabled={projectLocked} title={projectLocked ? 'Available in full version' : undefined} />
                <button
                  className="pill-btn pill-btn--icon"
                  type="button"
                  aria-label="Landscape"
                  aria-pressed={canvasPreset === 'landscape'}
                  onClick={() => setCanvasPreset('landscape')}
                  style={{ borderColor: canvasPreset === 'landscape' ? 'var(--accent)' : 'var(--border)' }}
                  title="Landscape"
                >
                  <img className="pill-btn__img" src={assetHref('ui/icon-landscape.png')} alt="" />
                </button>
                <button
                  className="pill-btn pill-btn--icon"
                  type="button"
                  aria-label="Portrait"
                  aria-pressed={canvasPreset === 'portrait'}
                  onClick={() => setCanvasPreset('portrait')}
                  style={{ borderColor: canvasPreset === 'portrait' ? 'var(--accent)' : 'var(--border)' }}
                  title="Portrait"
                >
                  <img className="pill-btn__img" src={assetHref('ui/icon-portrait.png')} alt="" />
                </button>
                <button className="pill-btn" type="button" onClick={handleUnlicense} title="Testing only">
                  <span>Unlicense</span>
                </button>

                  <button className="pill-btn" type="button" onClick={() => { setLogs([]); setRenderElapsedMs(0); setRenderTotalMs(0); }}>
                  <span>Clear Logs</span>
                  </button>
                    <span style={{ color: '#666' }}>Elapsed: {Math.floor((renderElapsedMs/1000))}s</span>
                  {renderTotalMs > 0 && (
                    <span style={{ color: '#666' }}>
                      ETA: {Math.max(0, Math.floor((renderTotalMs - renderElapsedMs)/1000))}s
                    </span>
                  )}


              <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'right', gap: 10 }}>
                <PillIconButton icon="ui/icon-sliders.png" label="Render" onClick={handleStartRender} disabled={projectLocked || !session.projectSavePath || isRendering} />
                <PillIconButton icon="ui/icon-x.png" label="Cancel" onClick={() => cancelRender()} disabled={projectLocked || !isRendering} />            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: 10 }}>
              </div>
              <button className="collapse-btn" type="button" onClick={() => toggleSection('project')} aria-label="Toggle project">
                <img src={assetHref(themedIcon(collapsed.project ? 'ui/icon-expand.png' : 'ui/icon-collapse.png'))} alt={collapsed.project ? 'Expand' : 'Collapse'} />
              </button>
            </div>
          </div>

          {!collapsed.project && (
            <div className="section-body" style={{ position: 'relative', opacity: projectLocked ? 0.45 : 1, pointerEvents: projectLocked ? 'none' : 'auto' }}>
              {projectLocked && (
                <div
                  style={{
                    position: 'absolute',
                    inset: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    padding: '12px 16px',
                    background: 'rgba(0, 0, 0, 0.65)',
                    color: '#f5f5f5',
                    fontSize: 16,
                    fontWeight: 700,
                    border: '1px dashed var(--border)',
                    borderRadius: 8,
                    textAlign: 'center',
                    lineHeight: 1.4,
                    zIndex: 2,
                    pointerEvents: 'none',
                  }}
                >
                  Trial Edition: Click here to upgrade to the Full Version.
                </div>
              )}
           

                {renderTotalMs > 0 && (
                  <div style={{ marginTop: '0.5rem', height: 10, background: '#222', borderRadius: 4, overflow: 'hidden' }}>
                    <div style={{ height: '100%', width: `${Math.min(100, Math.max(0, (renderElapsedMs / renderTotalMs) * 100)).toFixed(1)}%`, background: '#3f51b5' }} />
                  </div>
                )}
                <div style={{ marginTop: '0.5rem', padding: '8px', background: '#0b0b0b', border: '1px solid #333', borderRadius: 4, maxHeight: 200, overflow: 'auto', fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace', fontSize: 12 }}>
                  {logs.length === 0 ? (
                    <div style={{ color: '#777' }}>Render logs will appear here...</div>
                  ) : (
                    logs.map((l, i) => (<div key={i}>{l}</div>))
                  )}
                </div>
              </div>
          
          )}
        </div>
  </div>
        {/* Notes Row (collapsed by default) */}
        <div className="right section-block">
          <div className="section-header">
            <h2 style={{ margin: 0 }}>NOTES</h2>
            <PillIconButton icon="ui/button_notes.svg" label={showNotes ? 'Hide' : 'Show'} onClick={() => setShowNotes((v) => !v)} />
          </div>
          {showNotes && (
            <div className="section-body">
              <textarea
                id="session-notes"
                style={{ display: 'block', width: '100%', minHeight: '200px', marginTop: '0.5rem' }}
                value={String((session as any).notes ?? '')}
                onChange={handleNotesChange}
              />
              <div style={{ marginTop: '1rem', display: 'flex', gap: '0.5rem' }}>
                <button type="button" onClick={handleSave}>Save Session</button>
                <button type="button" onClick={handleExport}>Export Session</button>
              </div>
              {status && <p style={{ color: 'green' }}>{status}</p>}
              {error && (
                <p role="alert" style={{ color: 'red' }}>
                  {error}
                </p>
              )}
            </div>
          )}
        </div>
      </div>

      {contextMenu && (
        <div style={{ position: 'fixed', inset: 0, zIndex: 1100 }} onClick={closeContextMenu}>
          <div
            style={{
              position: 'absolute',
              top: contextMenu.y,
              left: contextMenu.x,
              background: 'var(--panel)',
              border: '1px solid var(--border)',
              borderRadius: 8,
              padding: 6,
              minWidth: 160,
              boxShadow: '0 8px 20px rgba(0,0,0,0.4)',
            }}
            onClick={(e) => e.stopPropagation()}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => startRenameClip(contextMenu.path, contextMenu.index)}>Rename</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => handleClipEdit(contextMenu.id, contextMenu.path, contextMenu.index)}>Edit</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => handleClipAddToLibrary(contextMenu.path)}>Add to Library</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => duplicateClipAt(contextMenu.index)}>Duplicate</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => handleClipInfo(contextMenu.path)}>File Info</button>
              <button className="pill-btn pill-btn--compact" type="button" onClick={() => removeClipAt(contextMenu.index)}>Remove</button>
            </div>
          </div>
        </div>
      )}

      {renameTarget && (
        <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', zIndex: 1200, display: 'flex', alignItems: 'center', justifyContent: 'center' }} onClick={() => setRenameTarget(null)}>
          <div style={{ background: 'var(--panel)', border: '1px solid var(--border)', borderRadius: 8, padding: 16, width: 360 }} onClick={(e) => e.stopPropagation()}>
            <h3 style={{ marginTop: 0 }}>Rename Clip</h3>
            <input
              type="text"
              style={{ width: '100%', marginBottom: 10 }}
              value={renameTarget.name}
              onChange={(e) => setRenameTarget((prev) => (prev ? { ...prev, name: e.target.value } : prev))}
            />
            <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end' }}>
              <button className="pill-btn" type="button" onClick={() => setRenameTarget(null)}>Cancel</button>
              <button className="pill-btn" type="button" onClick={applyRenameClip}>Save</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default App;
