import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { SessionState } from '../common/session';
import type { ExportSessionRequest } from './preload';
import { isProjectSchema } from '../common/project';
import { spawn } from 'node:child_process';

const SESSION_FILENAME = 'session.json';

const getSessionFilePath = () => path.join(app.getPath('userData'), SESSION_FILENAME);

async function ensureUserDataDir(): Promise<void> {
  const directory = app.getPath('userData');
  await fs.mkdir(directory, { recursive: true });
}

ipcMain.handle('session:load', async (): Promise<SessionState | undefined> => {
  const filePath = getSessionFilePath();

  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content) as SessionState;
  } catch (error: unknown) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return undefined;
    }

    console.error('[session:load] Failed to read session file:', error);
    throw error;
  }
});

ipcMain.handle('session:save', async (_event, state: SessionState): Promise<void> => {
  await ensureUserDataDir();
  const filePath = getSessionFilePath();

  try {
    const payload = JSON.stringify(state ?? {}, null, 2);
    await fs.writeFile(filePath, payload, 'utf-8');
  } catch (error) {
    console.error('[session:save] Failed to persist session state:', error);
    throw error;
  }
});

ipcMain.handle('session:export', async (_event, request: ExportSessionRequest): Promise<void> => {
  const { targetPath, state } = request;

  if (!targetPath) {
    throw new Error('No export path provided.');
  }

  try {
    await fs.mkdir(path.dirname(targetPath), { recursive: true });
    const payload = JSON.stringify(state ?? {}, null, 2);
    await fs.writeFile(targetPath, payload, 'utf-8');
  } catch (error) {
    console.error('[session:export] Failed to export session:', error);
    throw error;
  }
});

ipcMain.handle('render:cancel', async (): Promise<void> => {
  const child = currentRenderChild;
  if (!child) return;
  try {
    child.kill('SIGINT');
    setTimeout(() => {
      if (!child.killed) {
        try {
          if (process.platform === 'win32') {
            const { spawn: sysSpawn } = require('node:child_process');
            sysSpawn('taskkill', ['/PID', String(child.pid), '/T', '/F']);
          } else {
            child.kill('SIGKILL');
          }
        } catch {}
      }
    }, 750);
  } catch {}
  currentRenderChild = null;
  mainWindow?.webContents.send('render:cancelled');
});

ipcMain.handle('audio:open', async (): Promise<string | undefined> => {
  const result = await dialog.showOpenDialog({
    title: 'Select audio file',
    properties: ['openFile'],
    filters: [
      { name: 'Audio', extensions: ['wav', 'mp3', 'aac', 'flac', 'ogg', 'm4a'] },
      { name: 'All Files', extensions: ['*'] },
    ],
  });
  if (result.canceled || result.filePaths.length === 0) return undefined;
  return result.filePaths[0];
});

ipcMain.handle('videos:open', async (): Promise<string[]> => {
  const result = await dialog.showOpenDialog({
    title: 'Select video files',
    properties: ['openFile', 'multiSelections'],
    filters: [
      { name: 'Video', extensions: ['mp4', 'mov', 'mkv', 'avi', 'webm'] },
      { name: 'All Files', extensions: ['*'] },
    ],
  });
  if (result.canceled || result.filePaths.length === 0) return [];
  return result.filePaths;
});

ipcMain.handle('project:saveAs', async (_event, defaultPath?: string): Promise<string | undefined> => {
  const result = await dialog.showSaveDialog({
    title: 'Save project as JSON',
    defaultPath,
    filters: [{ name: 'Project JSON', extensions: ['json'] }],
  });
  if (result.canceled || !result.filePath) return undefined;
  // ensure folder exists
  await fs.mkdir(path.dirname(result.filePath), { recursive: true });
  return result.filePath;
});

ipcMain.handle('project:open', async (): Promise<{ path: string; project: unknown } | undefined> => {
  const result = await dialog.showOpenDialog({
    title: 'Open project JSON',
    properties: ['openFile'],
    filters: [{ name: 'Project JSON', extensions: ['json'] }],
  });
  if (result.canceled || result.filePaths.length === 0) return undefined;
  const filePath = result.filePaths[0];
  const content = await fs.readFile(filePath, 'utf-8');
  let parsed: unknown;
  try {
    parsed = JSON.parse(content);
  } catch (e) {
    throw new Error('Selected file is not valid JSON.');
  }
  // Basic shape validation; renderer can further validate
  if (!isProjectSchema(parsed)) {
    throw new Error('Selected file is not a valid MuvidGen project JSON.');
  }
  return { path: filePat
